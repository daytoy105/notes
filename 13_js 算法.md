1. 数组乱序(快速洗牌法)
	```javascript
	function shuffe(arr) {
	  var len = arr.length
	  if (len <= 1) {
	    return arr;
	  }
	  for (let i = 1; i < len; i++) {
	    var j = parseInt(Math.random() * (len - 1))
	    var tem = arr[j]
	    arr[j] = arr[len - 1 - i]
	    arr[len - 1 - i] = tem
	  }
	  return arr
	}
	```
2. 去掉一组整型数组重复的值(Object的使用，利用key来进行筛选)
	```javascript
	let unique = function(arr) {
	  let hashTable = {};
	  let data = [];
	  for (let i = 0, l = arr.length; i < l; i++) {
	    if (!hashTable[arr[i]]) {
	      hashTable[arr[i]] = true;
	      data.push(arr[i]);
	    }
	  }
	  return data
	}
	```
3. 统计一个字符串出现最多的字母
	```javascript
	function findMaxDuplicateChar(str) {
	  if (str.length == 1) {
	    return str;
	  }
	  let charObj = {};
	  for (let i = 0; i < str.length; i++) {
	    if (!charObj[str.charAt(i)]) {
	      charObj[str.charAt(i)] = 1;
	    } else {
	      charObj[str.charAt(i)] += 1;
	    }
	  }
	  let maxChar = '',
	    maxValue = 1;
	  for (var k in charObj) {
	    if (charObj[k] >= maxValue) {
	      maxChar = k;
	      maxValue = charObj[k];
	    }
	  }
	  return maxChar;
	}
	```
4. 排序算法
	1) 冒泡排序
		+ 算法描述：
			+ 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
			+ 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
			+ 针对所有的元素重复以上的步骤，除了最后一个；
			+ 重复步骤1~3，直到排序完成。
		```javascript
		function bubbleSort(arr) {
		  for (let i = 0, l = arr.length; i < l - 1; i++) {
		    for (let j = 0; j < l - 1 - i; j++) {
		      if (arr[i] > arr[j]) {
		        let tem = arr[i];
		        arr[i] = arr[j];
		        arr[j] = tem;
		      }
		    }
		  }
		  return arr;
		}
		```
	2) 插入排序
		+ 算法描述：
			+ 从第一个元素开始，该元素可以认为已经被排序；
			+ 取出下一个元素，在已经排序的元素序列中从后向前扫描；
			+ 如果该元素（已排序）大于新元素，将该元素移到下一位置；
			+ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
			+ 将新元素插入到该位置后；
			+ 重复步骤2~5。
		```javascript
		function insertSort(arr) {
		  for (var i = 1, len = arr.length; i < len; i++) {
		    var key = arr[i];
		    var j = i - 1;
		    while (arr[j] > key) {
		      arr[j + 1] = arr[j];
		      j--;
		    }
		    arr[j + 1] = key;
		  }
		  return arr;
		}
		```
	3) 选择排序
		+ 算法描述：
			+ 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
			+ 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
			+ 以此类推，直到所有元素均排序完毕。
		+ 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。
		```javascript
		function selectSort(arr) {　　
		  var minIndex, temp;　　
		  for (var i = 0, len = arr.length; i < len - 1; i++) {
		    minIndex = i;　　　　
		    for (var j = i + 1; j < len; j++) {
		      if (j >= 0 && arr[j] < arr[minIndex]) {
		        minIndex = j;
		      }
		    }　　　
		    temp = arr[i];　　　　
		    arr[i] = arr[minIndex];　　　　
		    arr[minIndex] = temp;　　
		  }　　
		  return arr;
		}
		```
	4) 归并排序
			+ 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。
			```javascript
			function mergeSort(arr) { //采用自上而下的递归方法
			  var len = arr.length;
			  if (len < 2) {
			    return arr;
			  }
			  var middle = Math.floor(len / 2),
			    left = arr.slice(0, middle),
			    right = arr.slice(middle);
			  return merge(mergeSort(left), mergeSort(right));
			}
			function merge(left, right) {
			  var result = [];
			  while (left.length && right.length) {
			    if (left[0] <= right[0]) {
			      result.push(left.shift());
			    } else {
			      result.push(right.shift());
			    }
			  }
			  return result.concat(left).concat(right)
			}
			```
			+ 迭代法实现
			```javascript
			function mergeSort(arr) {
			  var len = arr.length;
			  if (len < 2) {
			    return arr;
			  }
			  var work = []
			  for (var i = 0; i < len; i++) {
			    work.push([arr[i]])
			  }
			  work.push([])  // 如果数组长度为奇数
			  for (var lim = len; lim > 1; lim = (lim + 1) / 2) {
			    for (var j = 0, k = 0; k < lim; j++, k += 2) {
			      work[j] = merge(work[k], work[k + 1])
			    }
			    work[j] = [] // 如果数组长度为奇数
			  }
			  return work[0]
			}
			```
	5) 快速排序
		+ 算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，
		然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。
		```javascript
		function quickSort(arr) {
		  var len = arr.length
		  if (len <= 1) {
		    return arr;
		  }
		  let leftArr = [];
		  let rightArr = [];
		  let i = Math.floor(len / 2)
		  let mid = arr.splice(i, 1);
		  for (let i = 0; i < len - 1; i++) {
		    if (arr[i] > mid) {
		      rightArr.push(arr[i]);
		    } else {
		      leftArr.push(arr[i]);
		    }
		  }
		  return [].concat(quickSort(leftArr), mid, quickSort(rightArr));
		}
		```
5. 两个排序数组的中位数
	<br>题目描述： 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。
	<br>示例1： nums1 = [1, 3]， nums2 = [2] 中位数是 2.0
	<br>示例 2: nums1 = [1, 2]，nums2 = [3, 4]，中位数是 (2 + 3)/2 = 2.5
	```javascript
	function findMedianSortedArrays(nums1, nums2) {
	  var result = []
	  while (nums1.length > 0 && nums2.length > 0) {
	    if (nums1[0] < num2[0]) {
	      result.push(nums1.shift())
	    } else {
	      result.push(nums2.shift())
	    }
	  }
	  var res = result.concat(nums1).concat(nums2)
	  var middle = Math.floor(res.length / 2)
	  if (res.length % 2) {
	    return res[middle]
	  } else {
	    return (res[middle - 1] + res[middle]) / 2
	  }
	}
	```

6. 不借助临时变量，进行两个整数的交换: 输入 a = 2, b = 4 输出 a = 4, b =2
	```javascript
	//主要是利用 + – 去进行运算，类似 a = a + ( b – a)实际上等同于最后的a = b;
	function swap(a, b) {
	  b = b - a;
	  a = a + b;
	  b = a - b;
	  return [a, b];
	}
	```
7. 两大数相加
	```javascript
	function sumStrings(a,b){
    var res='', c=0;
    a = a.split('');
    b = b.split('');
    while (a.length || b.length || c){
      c += ~~a.pop() + ~~b.pop();
      res = c % 10 + res;
      c = c>9;
    }
    return res.replace(/^0+/,'');
	}
	```
8. 找出下列正数组的最大差值比如: 输入 [10,5,11,7,8,9]  输出 6
	```javascript
	function getMaxProfit(arr) {
	  var minPrice = arr[0];
	  var maxProfit = 0;
	  for (var i = 0; i < arr.length; i++) {
	    var currentPrice = arr[i];
	    minPrice = Math.min(minPrice, currentPrice);
	    var potentialProfit = currentPrice - minPrice;
	    maxProfit = Math.max(maxProfit, potentialProfit);
	  }
	  return maxProfit;
	}
	```
9. 随机生成指定长度的字符串: 实现一个算法，随机生成指制定长度的字符串，比如给定 长度 8  输出 4ldkfg9j
	```javascript
	function randomString(n) {
	  let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
	  let tmp = '',
	      i = 0,
	      l = str.length;
	  for (i = 0; i < n; i++) {
	    tmp += str.charAt(Math.floor(Math.random() * l));
	  }
	  return tmp;
	}
	```
11. 实现类似getElementsByClassName 的功能:	自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。
	```javascript
	function queryClassName(node, name) {
	  var starts = '(^|[ \n\r\t\f])',
	    ends = '([ \n\r\t\f]|$)';
	  var array = [],
	    regex = new RegExp(starts + name + ends),
	    elements = node.getElementsByTagName("*"),
	    length = elements.length,
	    i = 0,
	    element;
	  while (i < length) {
	    element = elements[i];
	    if (regex.test(element.className)) {
	      array.push(element);
	    }
	    i += 1;
	  }
	  return array;
	}
	```
10. 使用JS 实现二叉查找树(Binary Search Tree)
	+ 一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：
		+ 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
		+ 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
		+ 任意节点的左、右子树也分别为二叉查找树；
		+ 没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。
	```javascript
	class Node {
	  constructor(data, left, right) {
	    this.data = data;
	    this.left = left;
	    this.right = right;
	  }
	}
	class BinarySearchTree {
	  constructor() {
	    this.root = null;
	  }
	  insert(data) {
	    let n = new Node(data, null, null);
	    if (!this.root) {
	      return this.root = n;
	    }
	    let currentNode = this.root;
	    let parent = null;
	    while (1) {
	      parent = currentNode;
	      if (data < currentNode.data) {
	        currentNode = currentNode.left;
	        if (currentNode === null) {
	          parent.left = n;
	          break;
	        }
	      } else {
	        currentNode = currentNode.right;
	        if (currentNode === null) {
	          parent.right = n;
	          break;
	        }
	      }
	    }
	  }
	  remove(data) {
	    this.root = this.removeNode(this.root, data)
	  }
	  removeNode(node, data) {
	    if (node == null) {
	      return null;
	    }
	    if (data == node.data) {
	      // no children node
	      if (node.left == null && node.right == null) {
	        return null;
	      }
	      if (node.left == null) {
	        return node.right;
	      }
	      if (node.right == null) {
	        return node.left;
	      }
	      let getSmallest = function(node) {
	        if (node.left === null && node.right == null) {
	          return node;
	        }
	        if (node.left != null) {
	          return node.left;
	        }
	        if (node.right !== null) {
	          return getSmallest(node.right);
	        }
	      }
	      let temNode = getSmallest(node.right);
	      node.data = temNode.data;
	      node.right = this.removeNode(temNode.right, temNode.data);
	      return node;
	    } else if (data < node.data) {
	      node.left = this.removeNode(node.left, data);
	      return node;
	    } else {
	      node.right = this.removeNode(node.right, data);
	      return node;
	    }
	  }
	  find(data) {
	    var current = this.root;
	    while (current != null) {
	      if (data == current.data) {
	        break;
	      }
	      if (data < current.data) {
	        current = current.left;
	      } else {
	        current = current.right
	      }
	    }
	    return current.data;
	  }
	}
	```
