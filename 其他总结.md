# HTML
1. DOCTYPE（文档类型）的作用是什么？
	+ DOCTYPE是document type(文档类型)的简写，HTML5之前，HTML都是用SGML来书写的，DOCTYPE则用来声明文档类型，它可以告知SGML parser使用什么DTD来解析文档。 三种形式: 过渡的、 严格的、 框架的
 	+ H5中 `<!DOCTYPE html>`
2. 浏览器模式
	+ `标准模式`是指，浏览器按W3C标准解析执行代码；
	+ `怪异模式`则是使用浏览器自己的方式解析执行代码，因为不同的浏览器解析执行的方式不一样，所以称为怪异模式。
	+ 浏览器解析时到底使用标准模式还是怪异模式，与网页中DTD声明直接相关，DTD声明定义了标准文档的类型，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明，将使网页进入怪异模式。
3. cookies、sessionStorage 和localStorage 的区别
	+ sessionStorage和localStorage是web storage的两种储存方式， 其中sessionStorage是会话级别储存，在浏览器或页面关闭时数据就会销毁。而localStorage是持久化的本地储存，不刻意去删除数据, 数据是不会销毁的。
	+ 以上这两种方式只是客户端的储存，不会涉及到服务器储存。与之相比，每次发送HTTP请求时会将cookie添加到Cookie头字段，发送给服务器。
	+ 在储存量方面也有差异，单个cookie保存的数据不能超过4K，而localStorage和sessionStorage一般有5-10M。
4. \<script>、\<script async>和\<script defer>的区别。
	+ \<script>加载js文件会`阻塞`页面的渲染和交互，而async和defer都是`异步`加载js文件，期间不会才生阻塞，区别在于`async`是加载完之后`自动`执行`，defer`需要等到页面`加载之后`(`onload`)再执行。
5. 什么是渐进式渲染 (progressive rendering)？
	+ 指浏览器不用等待所有页面资源都渲染好之后再呈现给用户看，而是`边下载边渲染`，所以用户打开一个网页的时候往往不能第一时间看到所有内容，但是能够看到一个大概的样子，后续的内容浏览器会慢慢补上形成一个完整的页面，其实就是为了解决JS加载时间问题。
	+ 实现方法：需要服务器端渲染SSR，进行首屏渲染，直接返回JSON和页面。
6. HTML和XHTML有什么区别？
	+ 为了规范HTML，W3C结合XML制定了XHTML 1.0标准，这个标准没有增加任何新的tag，只是按照XML的要求来规范HTML。
	1) XHTML中的标签都必须被正确地嵌套，HTML中的某些标签可以彼此不正确的嵌套。
	2) XHTML中的所有标签必须要关闭。
	3) XHTML中规范定义：标签名和属性对大小写敏感,所有XHTML标签名必须用小写字母。
	4) XHTML文档必须拥有根元素。
	5) XHTML中标签的属性值要使用双引号
7. HMTL5新特性
	1) 新增的API
		+ 语义化标签：article、aside、footer、header、nav、section、hgroup、figure
		+ 表单：
			+ form属性：autocomplete、novalidate
			+ input属性：autocomplete、autofocus、form、height、 width、list、min、max、step、multiple、pattern (regexp)、placeholder、required
			+ input类型：email、url、number、range、Date pickers(date, month, week, time, datetime, datetime-local)、search、color
		+ 多媒体：video、 audio
		+ 2D/3D 绘图 & 效果： canvas、svg、webGL
	  + 离线应用、DOM存储(sessionStorage、localStorage、IndexDB) 
			```javascript
			if(window.applicationCache){/*支持离线应用*/ }
			```
			+ `manifest`文件是核心，记录着哪些资源文件需要离线应用缓存，要使用manifest，只需要在html标签中添加属性`<html manifest="cache.manifest">`
			+ `CACHE MANIFEST`是当网络不可用时，文件直接从本地缓存读取，`NETWORK`下面的文件无论是否已经缓存，都要从网络中下载。`FALLBACK`后面，当无法获取到offline.html，则转到index.html。
		+ 性能 & 集成： WebWorkers、HistoryAPI、拖放、requestAnimationFrame。 
		+ 设备访问Device Access：能够处理各种输入和输出设备(触控事件touch、使用地理位置定位、检测设备方向)
		+ 网络通信：web sockets、postMessage、XMLHttpRequest2、FileReader、FormData
	2) 移除的元素
		+ 纯表现的元素： basefont、big、center、font等
		+ 对可用性产生负面影响的元素： frame、frameset、noframes
8. UTF-8和GBK有什么区别
	+ GBK是在国家标准GB2312基础上扩容后兼容GB2312的标准（好像还不是国家标准）。GBK编码专门用来解决中文编码的，是双字节的。不论中英文都是双字节的。
	+ UTF-8编码是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24位（三个字节）来编码。对于英文字符较多的论坛则用UTF-8 节省空间。
	+ 另外，如果是外国人访问你的GBK网页，需要下载中文语言包支持。访问UTF-8编码的网页则不出现这问题。可以直接访问。GBK包含全部中文字符；UTF-8则包含全世界所有国家需要用到的字符。
9. canvas、svg
	1) svg
		+ SVG是一种使用`XML`描述2D图形的语言。
		+ SVG基于XML，这意味着SVG DOM中的每个元素都是可用的。您可以为某个元素附加JavaScript事件处理器。
		+ 在SVG中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形。
		+ `总结`：不依赖分辨率(矢量)，支持事件处理器，最适合带有大型渲染区域的应用程序（比如谷歌地图），复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快），不适合游戏应用
	2) canvas
		+ Canvas通过`JavaScript`来绘制2D图形。
		+ Canvas是逐像素进行渲染的。
		+ 在canvas中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
		+ `总结`：依赖分辨率，不支持事件处理器，弱的文本渲染能力，能够以 .png 或 .jpg 格式保存结果图像。最适合图像密集型的游戏，其中的许多对象会被频繁重绘。
10. 拖放
	1) 设置元素为可拖放, `draggable`属性设置为true
	2) 拖动和设置数据：ondragstart、setData()
		```javascript
		function drag(ev){
		  ev.dataTransfer.setData("Text",ev.target.id);
		}
		```
	3) 放到何处: ondragover
		<br>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式.这要通过调用ondragover事件的`event.preventDefault()`方法
	4) 进行放置和获取数据：ondrop、getData
		```javascript
		function drop(ev){
		  ev.preventDefault();
		  var data=ev.dataTransfer.getData("Text");
		}
		```
# CSS
1. "resetting" 和 "normalizing" CSS
	+ normalize相对平和，注重通用的方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些bug的修复，这点是reset所缺乏的。
	+ reset相对暴力，不管你有没有用，统统重置成一样的效果，且影响的范围很大，讲求跨浏览器的一致性。
	+ 实际开发中倾向于选择normalize.css ，主要是reset.css为几乎所有的元素施加默认样式，所以需要对所有公共的排版元素重新设置样式，这是一件很麻烦的工作。
2. 浮动 (float) 及其工作原理
	+ float属性定义了元素是否浮动及在哪个方向浮动，在CSS中`任何元素`都可以`浮动`，且浮动元素会生成一个`块级框`，而不论它本身是何种元素。并且盒子的宽度不在伸展，而是根据盒子里面的内容的宽度来确定。浮动属性会使得浮动的元素`脱离文档流`，所以文档的普通流中的块框会表现的像浮动框不存在一样。
3. 清除浮动
	1) 父级div定义伪类：after和zoom（重要）
	<br>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6，ie7浮动问题
	2) 在结尾处添加空div标签clear:both
	<br>原理：添加一个空div，利用css提供的clear:both清除浮动，让父级div能自动获取到高度
	3) 父级div定义height
	<br>原理：手动定义height，就解决了`父级div无法自动获取高度的问题`。
	4) 父级div定义overflow:hidden
	<br>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度
	5) 父级div也一起浮动
	<br>原理：所有代码一起浮动，就变成了一个整体
4. 描述z-index和叠加上下文是如何形成的？
	1) 负边距
	<br>堆叠顺序由元素在文档中的先后位置决定，后出现的会在上面。
	2) position的relative/absolute/fixed定位
	<br>堆叠顺序（stack order），值大的元素发生重叠时会在值小的元素上面。
5. BFC(Block Formatting Context) 及其如何工作？
	+ 定义：一个块级格式化上下文，[BFC]是可视化CSS渲染网页的一部分，它是一个区域，块级布局，相互浮动在这个区域发生。它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。
	+ BFC布局规则：
		1) 内部的Box会在垂直方向，一个接一个地放置。
		2) Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
		3) 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
		4) BFC的区域不会与float box重叠。
		5) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
		6) 计算BFC的高度时，浮动元素也参与计算
	+ 有哪些方式能够触发BFC模式？
		1) 根元素（根元素可产生独立BFC）
		2) float属性不为none（总结为脱离文档流）
		3) position为absolute或fixed（总结为脱离文档流）
		4) display为inline-block、table-cell
		5) overflow`不为`visible
	+ BFC有哪些应用？
		1) 清除内部浮动
		<br>我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生`高度塌陷`，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。
		2) 垂直margin合并
		<br>在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
		<br>折叠的结果：
			+ 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
			+ 两个外边距一正一负时，折叠结果是两者的相加的和。这个同样可以利用BFC解决。
		3) 页面布局
		4) 避免文字环绕图片(当图片float为lef， 文字的标签变成BFC)
	+ 总结：因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理
	+ IFC：内联格式化上下文（display:inline），容器里面的子元素不会影响到外面的元素，表示盒子从左到右的水平排列方式；
		+ 影响IFC的CSS属性有： font-size 、line-height、heigth、vertail-align
		+ 作用：
			1) 水平居中 text-align:center
			2) 垂直居中： vertical-align: middle
	+ GFC：网格布局格式化上下文（display:grid）；
	+ FFC：自适应格式化上下文（display:flex）；
6. CSS sprites
	+ CSS Sprites是一种网页图片应用处理方式，就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的"`background-image`"，"`background-repeat`"，"`background-position`"的组合进行背景定位。
	+ 优点
		1) 减少网页的http请求，提高性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；
		2) 减少图片的字节：多张图片合并成1张图片的字节小于多张图片的字节总和；
		3) 减少了命名困扰：只需对一张集合的图片命名，不需要对每一个小元素进行命名提高制作效率；
		4) 更换风格方便：只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。
	+ 缺点
		1) 图片合成比较麻烦；
		2) 背景设置时，需要得到每一个背景单元的精确位置;
		3) 维护合成图片时，最好只是往下加图片，而不要更改已有图片。
7. 图片替换文字方案
	1) 伪对象覆盖方法
		```css
		.ele:after {
		  background: url(img/logo.jpg) no-repeat;
		}
		```
	2) 使用 display:none 的方式
		<br>隐藏的内容将被许多主流屏幕阅读器忽略，从而造成可用性问题，因此，应该尽量避免使用。同时当图片无法显示时，将导致这个区域没有任何内容
	3) 通过文本缩进text-indent
		<br>将其设为负值，将文字隐藏，当图片无法显示时，将导致这个区域没有任何内容
	4) 利用定位的方式
		<br>这种方法的原理是将`span标签`覆盖在文字内容上面，一旦span里面的背景图无法显示，将显示下层的文字内容，不影响正常使用。但是，此方法也有一个缺陷，就是背景图不能透明，否则将透出下面的文字。
8. 如何为有功能限制的浏览器提供网页？
	+ `渐进增强`：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
	+ `优雅降级`：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
	+ 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带
9. 有哪些的隐藏内容的方法？
	1) display：none;
		<br>搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略，`屏幕阅读器`（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。所以这个方法并不适用。
	2) visibility: hidden ;
		<br>隐藏的内容会`占据占据物理空间`。即内容虽然被隐藏，但是它所在的文档流的位置变成空白，会占据页面上的空间。
	3) overflow：hidden；
		<br>可以达到隐藏内容的目的且同时可以被屏幕阅读器可用。
	4) 利用定位将内容移出屏幕。
	5) 内容透明度设置为0.
10. 栅格系统 (grid system)
	+ “网格系统”，运用固定的格子设计版面布局，其风格工整简洁。
	+ Bootstrap内置了一套响应式、移动设备优先的流式栅格系统，随着屏幕设备或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义class，还有强大的mixin用于生成更具语义的布局。
11. 媒体查询，移动端的布局CSS
	+ viewport
		+ 通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域。移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。
		+ `ideal viewport`的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。
		+ 当前的viewport宽度设为ideal viewport的宽度，既可以设置width=device-width，也可以设置initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就initial-scale=1解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病。
		+ 缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。
		+ 在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。
		```html
		<meta name = "viewport" content = "width=device-width,initial-scale=1" >
		```
	+ 媒体查询(media query)目的在于为指定的视图宽度指定不同的CSS规则，来实现不同的布局。
	```css
	/*
	@media mediatype and|not|only (media feature) {
	  CSS-Code;
	}
	mediatype： print: 用于打印机和打印预览 screen: 用于电脑屏幕，平板电脑，智能手机等。
	orientation: landscape(横屏) | portrait(竖屏)
	*/
	@media only screen and (max-width: 500px) {
	  .gridmenu {
	    width: 100%;
	  }
	}
	```
12. 如何优化网页的打印样式？
	```html
	<link rel="stylesheet" type="text/css" media="screen" href="xxx.css" />
	<link rel="stylesheet" type="text/css" media="print" href="yyy.css" />
	```
	+ 其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。
	+ 但打印样式表也应有些注意事项：
		1) 打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。
		2) 最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。
		3) 隐藏掉不必要的内容。（@print div{display:none;}）
		4) 打印样式表中最好少用浮动属性，因为它们会消失。
13. CSS预处理器的优缺点？
	+ CSS预处理器用一种专门的编程语言，在编写CSS的过程中可以使用变量、循环、递归等特性，然后再编译成正常的CSS文件，可以提高CSS编写效率，转换工具： `koala`
14. display属性的全部值
	1) inline
		+ inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。
		+ inline元素设置width, height属性无效。
		+ inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。
	2) inline-block:
		<br>元素可以设置宽度和高度，同时inline-block元素又可以在同行进行排列。
	3) block
		+ block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。
		+ block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。
		+ block元素可以设置margin和padding属性。
	4) flex
		<br>意为"弹性布局"，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
15. relative、fixed、absolute和static的区别
	1) absolute：
		<br>不占据空间，生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位，如果元素没有已定位的父元素，那么它的位置相对于\<html>
	2) relative：
		<br>元素原本所占的空间仍保留
	3) fixed：
		<br>不占据空间， 生成绝对定位的元素，相对于`浏览器窗口`进行定位。
	4) static：
		<br>默认值。没有定位，元素出现在正常的流
16. 响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同？
	1) 自适应布局（Adaptive）元素的位置会变化而大小不会变化；
	2) 流式布局（Liquid）的特点（也叫“Fluid”) 是页面元素的宽度调整元素大小。
	3) 响应式布局（Responsive Layout）即元素大小和位置都变化。
17. 你有兼容retina屏幕的经历吗？如果有，在什么地方使用了何种技术？
	+ iPhone 6s的屏幕为4.7英寸1334 x 750像素，苹果的一款电脑MacBook Pro达到了2880×1800高分辨率，分辨率约为220 PPI，达到“Retina”级别，而我们普通电脑的屏幕比较高清的有14寸1920X1080。
	1) 同样尺寸的图片变得模糊
		<br>核心问题在于：Retina屏将传统的四个物理像素点模拟一个像素点。由于这个原因，几乎所有的图片甚至是字体，都有可能出现模糊的情况
	2) 网页元素宽度高度有半个像素的概念
		+ 表现：在6s上前端界面底部出现了一条白色亮线。
		+ 原理：在我们以往的前端经验中，px为单位的长度没有办法再进行切割，我们在css中写12.5px这样的写法是没有效果的，因为传统屏幕中一个px就是一个px，没有0.5px的概念。这是由传统屏幕的性质决定的，一个物理像素和一个逻辑像素是一一对应的。但是四个物理像素模拟一个物理像素的高分辨率屏出现后，这种特性被打破。当一个网页元素的宽度或高度不是整数，而出现小数位长度的时候就会出现一条白线，
		+ 解决：避免小于0.5px单位的长度出现，当长度大于0.5px的时候，就会完全占满四个物理像素组成的一个逻辑像素。因此，尽可能在一些颜色与邻近元素对比度大的元素中，采用绝对长度单位px，而不使用% em rem pt等非绝对长度单位。不过，Retina屏为更小精度的定位提供了可能，你甚至可以采用0.4px这样的方法来专门为Retina屏进行一些适配。
18. 为何要使用translate而非position，或反之的理由？为什么？
	+ 从动画角度来说 使用transform或position 实现动画效果时是有很大差别。使用 transform 时，可以让 `GPU` 参与运算，动画的 FPS 更高。使用position时，最小的动画变化的单位是 1px，而使用 transform 参与时，可以做到更小（动画效果更加平滑）
	+ 总结position是为页面布局而生的。 transform是为动画而生的，不会引起DOM重排。
19. 为什么无法定义 1px左右高度的容器
	<br>IE6下这个问题的原因为默认的行高造成的，解决的方法有很多，例如：overflow:hidden | zoom:0.08 | line-height:1px
20. 性能动画方面，为什么用css3
	+ 尽可能多的利用硬件能力，如使用3D变形来开启GPU加速
	+ CSS动画属性会触发整个页面的重排(relayout)、重绘(repaint)、重组(recomposite)
		+ Paint通常是其中最花费性能的，尽可能避免使用触发paint的CSS动画属性，这也是为什么我们推荐在CSS动画中使用`transform:translateX(3em)`的方案代替使用`left:3em`，因为left会额外触发`layout`与`paint`，而`transform`只触发整个页面`composite`
21. css选择符有哪些，哪些属性可以继承，优先级如何计算
	+ css选择符
		1) id 选择器， 优先级高
		2) 类选择器， 优先级中
		3) 元素选择器，优先级低
		4) 群组选择器， `逗号(,)`分隔
		5) 后代选择器，`空格( )`分隔
		6) 子代选择器，`大于号(>)`分隔
		7) 兄弟选择器
			+ 相邻兄弟选择器 `加号(+)`分隔
	 		+ 通用兄弟选择器  `~`分隔    (css3)
		8) 属性选择器
			+ css2:
			<br>p[id]：匹配所有具有id属性的p元素
			<br>p[id=val]：匹配所有id属性等于"val"的p元素
			<br>p[class~=val]：匹配class属性的p元素，其中class属性的值是以空格隔开
			+ css3:
			<br>p[id^=val]：属性id的值以"val"开头的元素
			<br>p[id$=val]：属性id的值以"val"结尾的元素
			<br>p[id*=val]：属性id的值包含"val"的元素
		9) 伪类选择器 `:`

		10) 通配符选择器，显示为一个星号(`*`)可以与任何元素匹配,浏览器解析时会把`*`里的样式在所有的选择器中都复制一遍。执行效率低
	+ 继承
		1) `文本相关`属性：以`text-`、`font-`、`line-` 开头的属性都是可以继承的。但是`a标签`的字体颜色不能被继承， `h标签`字体的大小也是不能被继承的，div 标签的高度如果不设置由内容来决定（没有内容高度为0），宽度默认由父元素继承过来
		2) `列表相关`属性：list-style-image,list-style-position,list-style-type,list-style
	+ 优先级: !important、 内联样式、 #id、 .class、 element
22. 伪元素 (pseudo-elements)、伪类及其用途
	+ 伪元素：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。装饰内容而不需要更改HTML的内容，从而帮助内容与样式更好地分离。
	+ 伪类： 逻辑上存在但在文档树中却无须标识的“幽灵”分类
	+ 伪类和伪元素的根本区别在于：它们是否创造了新的元素(抽象)。
	1) 链接伪类(定义链接样式)
		<br> :link  :visited
	2) 动态伪类(定义交互样式)
		+ :hover  :active  :focus
		+ a 超链接设置顺序 , a:link  a:visited  a:hover  a:active
	3) 伪元素选择器  （CSS2）
		<br> ::before、::after、::first-letter、::first-line
	4) 用户界面相关的伪类 (CSS3新增)
		<br> :enabled、:disabled、:checked 、::section
	5) 否定伪类  (CSS3新增)
		<br> :not(p)
	6) 结构伪类  (CSS3新增)
		<br> :first-child、:last-child、:nth-child(n)、:empty、 :only-child
	7) 目标伪类  (CSS3新增)
		<br> :target， 匹配文档中特定`id`点击后的效果
23. 文本属性
	1) text-overflow， （CSS3）文本溢出，中英文都有效果
		+ ellipsis : 省略号
		+ clip: 裁剪
		+ 作用：配合overflow:hidden; white-space:nowrap 使用，单行显示...
	2) word-break
		+ break-all：允许在单词内换行
		+ keep-all：只能在半角空格或连字符处换行
	3) word-wrap（针对英文的长单词）
		+ break-word:在长单词或 URL 地址内部进行换行
	4) white-space （中文都可以）
		+ normal: 空白会被浏览器忽略。
		+ pre: 空白会被浏览器保留。其行为方式类似HTML中的\<pre>标签。
		+ nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到\<br>标签为止。
		+ pre-wrap: 保留空白符序列，但是正常地进行换行。
		+ pre-line: 合并空白符序列，但是保留换行符。
24. 浏览器是如何判断元素是否匹配某个CSS选择器
	+ 浏览器会根据`css rules`与`dom tree`生成`render tree`。浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到整个选择器都匹配完，还在集合中的元素就匹配这个选择器了。
	+ 解析顺序： 从上到下， 从右到左
25. rem、 em、 px、 rpx
	+ px，像素（计算机屏幕上的一个点）
	+ rem 单位翻译为像素值是由`html元素`的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。
	+ em 单位转为像素值，取决于他们使用的字体大小。此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位。 em 适用于在非默认字体大小的元素上的padding、 margin、 width、 height和line-height。
	+ rpx，小程序上的单位换算，iphone 6屏幕上，750rpx = 375px
26. CSS3的box-sizing的作用
	+ 设置CSS盒模型为标准模型或IE模型。 标准模型的宽度只包括content, IE模型包括border和padding。
 	+ box-sizing 属性可以分为三个值之一
 		+ content-box，默认值，border和padding不计入width之内
		+ padding-box，padding计入width内
		+ border-box，border和padding计入width内
27. css引入的方式有哪些？ link和@import的区别是？
	+ 内联 \<span style="width:100px;height:100px;display:inline-block">\</span>
	+ 内嵌 \<style>\</style>
	+ 外链 \<link href="xx.css" rel="stylesheet">
	+ 导入 \@import
	+ 外链与导入的区别:
		+ 前者无兼容性， 后者css2.1以下浏览器不支持
		+ Link支持使用javascript改变样式，后者不可

# Javascript
1. 事件
	1) 事件流
	 + 事件捕获、目标阶段、事件冒泡
	 + IE8 以下不支持事件捕获
	2) 冒泡机制
		<br>事件冒泡发生的条件：当为多个嵌套的元素设置了相同的事件处理程序，它们将触发事件冒泡机制。在事件冒泡中，最内部的元素将首先触发其事件，然后是栈内的下一个元素触发该事件，以此类推，直到到达最外面的元素。如果把事件处理程序指定给所有的元素，那么这些事件将依次触发。
	3) 事件代理
		<br>事件代理是利用事件的冒泡原理来实现的，通过在父元素子绑定事件处理程序，作用于其下的所有子元素，减少页面的dom元素的事件。过程：点击子元素，通过事件冒泡至父元素，然后在父元素上处理事件。
2. this
	+ es 5
		1) 在一般函数方法中使用 this 指代全局对象(非严格模式)，或undefined(严格格式下)
		2) 作为对象方法调用，this指代上级对象，不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。
		3) 作为构造函数调用，this指代new的实例对象
		4) apply或者call调用 ，作用是改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数
		5) bind()函数中，指向传入的对象
	+ es6
		1) 在箭头函数中，this指向定义时的对象
		2) class中，在静态方法中，this指向当前类，在普通方法中，this指向类的实例。
		2) 在子类通过super属性调用父类方法时，在静态方法中，方法内部的this指向当前子类，普通方法中，方法内部的this指向子类实例
3. javascript继承
	1) 原型链
		`Child.prototype = new Parent()`
	2) 构造函数方式
	```javascript
	function Child() {
	  Parent.call(this)
	}
	```
	3) 组合继承
	```javascript
	function Child() {
	  Parent.call(this)
	}
	Child.prototype = new Parent()
	```
	4) 原型式继承 (object.create)
	```javascript
	function object(o) {
	  function F(){}
	  F.prototype = o;
	  return new F()
	}
	```
4. javascript模块化
	1) CommonJS
		<br>CommonJS定义模块分为：模块引用(require)、模块导出(exports)、模块标识	(module)
		```javascript
		//模块加载原理：
		var module = {
		  exports: []
		};
		(function(module, exports) {
		  // 需要导出的模块
		  exports.mutiply = function(n) { return n * 1000 };
		}(module, module.exports))
		var f = module.exports.mutiply;
		f(5); // 5000
		```
	2) AMD
		<br>AMD也是通过require引入模块，但不同于commonJS的是，它需要传入一个callback方法。AMD模块使用define()定义
		```javascript
		require(['math'], function(math) {
		  math.add(2, 3);
		})
		```
	3) es6的import和export
5. null 、undefined区别
	+ undefined，在使用var声明变量但未对其加以初始化时，这个变量就是undefined。
		```javascript
		typeof undefined //undefined.
	  String(undefined)   // undefined
		Number(undefined)   // NaN
		```
	+ null，是一个空指针对象
		```javascript
		typeof null //object.
	  String(null)   // null
		Number(null)   // 0
		```
6. 闭包与作用域
	+ 闭包：是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。
	+ 作用域：
		+ 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
		+ 作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境;全局执行环境的变量对象始终是作用域链中的最后一个对象。
7. 你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？
	1) 模式：
		<br>单例模式、观察者模式、中介者模式、 装饰者模式、 迭代者模式
	2) 继承, es6 class语法
	3) 模块化：es的import和export
8. 宿主对象 (host objects) 和原生对象 (native objects)
	+ 本地对象就是 ECMA-262 定义的类
		+ String、Number、Boolean、Array、Function、RegExp、Math、Date、Error、Object、Global
	+ 所有非本地对象都是宿主对象（host object），即由ECMAScript实现的宿主环境提供的对象。
		+ BOM： winodw、navigator、location、history、screen
		+ DOM
9. apply、 call、 bind
	+ apply()和call()能够扩充函数赖以运行的作用域，好处是就是对象不需要与方法有任何耦合关系。
	+ bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。es3实现，使用一个闭包返回一个函数。
10. 柯里化
	<br>它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。
	```javascript
	function curry(fn) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  return function() {
	    var innerArgs = Array.prototype.slice.call(arguments);
	    var finalArgs = args.concat(innerArgs);
	    return fn.apply(null, finalArgs); //null， 表示不考虑执行环境
	  }
	}
	```
11. new
	```javascript
	function New(f) {
	  return function() {
	    var o = {
	      "__proto__": f.prototype
	    };
	    f.apply(o, arguments);
	    return o;
	  }
	}
	```
	+ new 操作符，调用构造函数的步骤：
		1) 创建一个新对象
		2) 将构造函数的作用域赋给新对象(因此this就指向了这个新对象)
		3) 执行构造函数中的代码(为这个新对象添加属性)
		4) 返回新对象
12. Ajax工作原理
	+ Ajax的原理简单来说通过`XMLHttpRequest对象`来向服务器发送`异步请求`，从服务器获得数据，然后用javascript来操作DOM而更新页面。
	+ readyState含义
		+ 0 : 请求尚未开始
		+ 1 ：服务器连接已建立
		+ 2 ：请求已接收
		+ 3 ：请求处理中
		+ 4 ：响应完成
13. 跨域
	+ 同源策略 (same-origin policy)
	<br>限制从一个源加载的文档或脚本如果与来自另一个源的资源进行交互。一个源指： 主机名，协议和端口号的组合，必须相同
	1) 图像Ping
		+ 图像Ping是与服务器进行简单、`单向`的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204 响应。通过图像Ping, 浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收的。
		+ 缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。
	2) JSONP
		+ JSONP原理的是`script`标签的`src属性`不受同源策略的影响，和图像ping的原理一样。
		+ 由两部分组成：回调函数和数据。回调是当响应来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。
		+ JOSNP与图像Ping相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间的`双向通信`。
		+ 缺点，只能发送GET请求，安全性不能确保；要确定JSONP请求是否失败并不容易。
	3) CORS
		<br>CORS (Cross-Origin Resource Sharing, 跨源资源共享)，背后的基本思想，就是使用`自定义的HTTP头部`让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 服务器如果认为这个请求可以接受，就在`Access-Control-Allow-Origin`头部中回发相同的源信息(如果是公共资源，可以是'*')
	4) document.domain，只能用于同一主域下的不同子域的通信
	5) H5新的特性： postMessage，websocket，兼容性
14. attribute 和 property
	+ attribute
		<br>是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute；
	+ property
		<br>是js获取的DOM对象上的属性值, 可以将它看作为一个基本的js对象。这个节点包括很多property，比如value，className以及一些方法onclik等方法
15. document load和document DOMContentLoaded
	+ DOMContentLoaded: 是指页面元素加载完毕，但是一些资源比如图片还无法看到，但是这个时候页面是可以正常交互的，比如滚动，输入字符等。 jQuery 中经常使用的 $(document).ready() 其实监听的就是 DOMContentLoaded 事件
	+ load：是指页面上所有的资源（图片，音频，视频等）加载完成。jQuery 中 $(document).load() 监听的是 load 事件。
	+ DOM文档加载的步骤为
		1) 解析HTML结构构建DOM树
		2) 加载外部脚本和样式表文件
		3) 解析并执行脚本代码
		4) DOM树构建完成//DOMContentLoaded
		5) 加载图片等外部文件
		6) 页面加载完毕//load
16. strict模式
	+ 变量必须声明后再使用
	+ 函数的参数不能有同名属性，否则报错
	+ 不能使用with语句
	+ 不能对只读属性赋值，否则报错
	+ 不能使用前缀0表示八进制数，否则报错
	+ 不能删除不可删除的属性，否则报错
	+ 不能删除变量delete prop，会报错，只能删除属性delete global
	+ eval不会在它的外层作用域引入变量
	+ eval和arguments不能被重新赋值
	+ arguments不会自动反映函数参数的变化
	+ 不能使用arguments.callee
	+ 不能使用arguments.caller
	+ 禁止this指向全局对象
	+ 不能使用fn.caller和fn.arguments获取函数调用的堆栈
	+ 增加了保留字（比如protected、static和interface）
17. 单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)
	+ spa指的是single page application，就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。
	+ 优点：
		1) 分离前后端关注点，前端负责view，后端负责model，各司其职；
		2) 服务器只接口提供数据，不用展示逻辑和页面合成，提高性能；
		3) 用户体验好、快，内容的改变不需要重新加载整个页面
		4) 可以缓存较多数据，减少服务器压力
	+ 缺点：
		1) SEO问题(服务器端渲染SSR)
		2) 首屏加载
		3) 路由问题，用户需要手动编写或引入第三方库；
		4) 页面复杂度提高很多，复杂逻辑难度成倍
18. 回调嵌套、Promise、Generator、async
	+ Promise是一个对象，从它可以获取异步操作的消息，调用then()执行处理结果，链式调用。
	+ Generator，返回的是一个iterator对象，不能自动执行，需手动调用next()，需配合thunk/co模块自动执行，同步的方式书写异步代码
	+ async，封装了自动执行器的generator语法糖，返回的是一个promise对象。async/await语义上更加合理
19. javascript调试工具
	+ chrome的断点：使用debugger语句可以在源代码中增加断点。一旦到达debugger语句，执行中断。
	+ conosle.log
	+ dev-tool(react/vue)
20. 对象遍历和数组遍历
	+ 对象遍历： for...in
	+ 数组遍历： for、 for...of 、forEach()、map()
21. 可变对象和不可变对象
	+ 不可变对象
		<br>JavaScript中原始值（undefined、null、布尔值、数字、字符串、symbol）这些都是不可变原始值。不可变说的是一旦这些基本类型值创建后会一直保存其内存地址，直到被浏览器的垃圾回收机制回收
	+ 可变对象
		<br>可变对象指的是，即使你创建了两个相同属性和值的对象，他们也不是同一个对象，它们各自占有自己的内存地址，如对象（包括数组和函数）
22. 事件循环 (event loop)
	+ JS单线程：
		<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
	+ 任务队列：
		+ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。`同步任务`指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；`异步任务`指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
		+ 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）
			1) 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
			2) 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
			3) 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
			4)	主线程不断重复上面的第三步。
	+ 事件和回调函数：
		+ 所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。
		+ "任务队列"是一个`先进先出`的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。
	+ `事件循环`:
		<br>主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）
	+ 定时器：
		<br>只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。
	+ Node.js的运行机制如下。
		1) V8引擎解析JavaScript脚本。
		2) 解析后的代码，调用Node API。
		3) libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
		4) V8引擎再将结果返回给用户。
	+ process.nextTick()
		<br>可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。也就是说，它指定的任务总是发生在所有`异步任务之前`。
	+ setImmediate()
		<br>在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在`下一次Event Loop`时执行，这与setTimeout(fn, 0)很像。
23. 数组的方法
 	+ indexOf() lastIndexOf() join() reverse() sort() concat() slice() splice() push() pop() unshift() shift() forEach() map() filter() every () some() reduce() reduceRight()
	+ Array.of() Array.from() find() findIndex() includes() entries() keys() values() flat() flatMap() fill()
24. web worker
	+ 自JavaScript诞生以来，还没有办法在浏览器UI线程之外运行代码。Web Workers API改变了这种状况，它引入了一个接口，能使代码运行且不占用浏览器UI线程的时间
	+ web Workers给Web应用带来潜在的巨大性能提升，因为每个新的Worker都在自己的线程中运行代码。这意味着Worker运行代码不仅不会影响浏览器UI，也不会影响其他Worker运行的代码。
25. 深拷贝和浅拷贝
	1) 浅拷贝：
		+ 拷贝自身一层的所有属性，若成员中存在对象或数组类型，则保留其引用地址
		+ Array.concat()、Array.slice()、扩展运算符(...)、fil()、Object.assgin()
	2) 深拷贝
		+ 深拷贝：完全拷贝了父对象及其子对象。（递归所有嵌套对象或者数组内容）
		+ var obj1 = JSON.parse(JSON.stringify(obj))
		```javascript
		var deepClone = function(o) {
		  var copy = Object.create(Object.getPrototypeOf(o));
		  var propNames = Object.getOwnPropertyNames(obj) //自身的所有属性(不含Symbol)
		  propNames.forEach(function(name) {
		    var desc = Object.getOwnPropertyDescriptor(o, name);
		    Object.defineProperty(copy, name, desc);
		  });
		  return copy;
		}
		```
		```javascript
		function deepClone(obj) {
		  let objClone = Array.isArray(obj) ? [] : {};
		  if (obj && typeof obj === "object") {
		    for (key in obj) {
		      if (obj.hasOwnProperty(key)) {
		        if (obj[key] && typeof obj[key] === "object") {
		          objClone[key] = deepClone(obj[key]);
		        } else {
		          objClone[key] = obj[key];
		        }
		      }
		    }
		  }
		  return objClone;
		}
		```
	3) jq的extend()
		+ $.extend( [deep ], target, object1 [, objectN ] )
		+ deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝，target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。
26. 图片懒加载
	<br>`<img src=’xxx’,data-src=’xxx’>`。页面滚动到该位置时，替换图片src属性
27. 实现页面加载进度条
 	<br> 函数体内设置一个随机数作为进度条要达到的中间值， setTimeout()的定时器处理进度条百分比的随机自增，并判断有无到达中间值，若没有，进度条百分比的随机自增，然后递归调用该函数。到达中间值后，清除定时器，把中间值赋值给现在的进度条的数。最后等待 window.load事件中处理剩余的进度条事件。可增加一个页面等待时间，页面onload事件超时也要显示完百分比。
28. 箭头函数ES5如何实现? 箭头函数和普通函数的区别
	`var f = v => v;`
	+ 使用注意点
		1) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
		2) 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
		3) 不可以使用arguments对象，该对象在函数体内不存在。可以用rest参数代替
		4) 不可以使用yield命令，因此箭头函数不能用作Generator函数
29. prototype和proto的关系是什么？
	+ 实例的`__propto__`属性指向其构造函数的`prototype`对象
30. 编写web端cookie的设置和获取方法
	```javascript
	function setCookie(name, value, day) {
		day = day || 1
	  var exp = new Date();
	  exp.setTime(exp.getTime() + day * 24 * 60 * 60 * 1000);
	  document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString();
	}
	function getCookie(name) {
	  var arr2, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
	  if (arr2 = document.cookie.match(reg)) {
	    return unescape(arr2[2])
	  } else {
	    return ''
	  }
	}
	function delCookie(name) {
	  var exp = new Date();
	  exp.setTime(exp.getTime() -1);
	  var cval=getCookie(name);
		if(cval!=null)
		  document.cookie= name + "="+cval+";expires="+exp.toGMTString();
		}
	}
	```
31. js的uglify如何实现
	+ 变量名由长变短
	+ 去除注释
	+ 所有空格回车都被压缩了挤成一行
# React
1. 虚拟DOM是啥？以及diff算法原理
	+ Virtual DOM是React的核心与精髓所在。Virtual DOM实际上是在浏览器端用JavaScript实现的一套DOM API，它之于React就好似一个虚拟空间，包括一整套Virtual DOM模型、生命周期的维护和管理、性能高效的diff算法和将Virtual DOM展示为原生DOM的Patch方法等。
	+ diff会帮助我们计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。tree diff、component diff 以及element diff进行算法优化。
2. react事件绑定
	+ bind 方法
	+ 双冒号 ::
	+ 构造器内声明
	+ 箭头函数
3. 生命周期
	<br>挂载、渲染、卸载
4. 函数式编程，纯函数
	+ React把过去不断重复构建UI的过程抽象成了组件，且在给定参数的情况下约定渲染对应的UI界面。React能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。可以说，`函数式编程才是React的精髓`
	+ 纯函数
		1) 给定相同的输入，它总是返回相同的输出；
		2) 过程没有副作用(side effect);
		3) 没有额外的状态依赖。
5. React创建组件的方式
	1) ES6 classes
	2) 无状态函数
6. 组件性能优化
	1) PureComponent
		<br>其原理为重新实现了shouldComponentUpdate 生命周期方法，让当前传入的props和state与之前的作浅比较，如果返回false，那么组件就不会执行render方法。
	2) Immutable
		<br>实现的原理是`持久化的数据结构`(persistent datast ructure)，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗，Immutable使用了`结构共享`(structural sharing)，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。
	3) key
		<br>它是用来标识当前项的唯一性的props，可以减少不必要的增加和删除
7. 调用setState之后发生了什么，结合源码分析
	+ `setState()`在实现上主要有两个方法，enqueueSetState()和performUpdateIfNecessary()。
	+ 调用setState()之后，执行enqueueSetState()方法，进行state的合并，并通过enqueueState()进行state的更新。当_pendingStateQueue不为空，performUpdateIfNecessary()会调用updateComponent()进行组件更新，updateComponent()会调用shouldComponentUpdate()和componetWillUpdate()方法，所以这也是不能在这两个方法上调用setState()的原因，会形成循环调用导致程序崩溃。同时触发re-render()构建新的元素树，在这个过程中，高效的dom diff算法能高效的寻找到需要变更的DOM节点，并只对变化的部分通过pacth()转化为真实dom，渲染输出在浏览器上。
8. Refs
	+ 表示为对组件真正实例的引用，其实就是ReactDOM.render()返回的组件实例。
	+ 是React组件中非常特殊的prop，可以附加到任何一个组件上，组件被调用时会新建一个该组件的实例，而refs就会指向这个实例。
9. react16新特性,time slice和suspense
	+ time slice, 主要解决CPU速度问题
		<br> 得益于fiber，使得在执行任务的期间可以随时暂停，去做其他事情。这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能。
	+ Suspense主要解决网络IO问题
		<br>调用render函数->发现有异步请求->悬停，等待异步请求结果->再渲染展示数据
		+ Suspense特性：
			1) 引入新的api，可以使得任何state更新暂停，直到条件满足时，再渲染（像async/await）
			2) 可以在任何一个组件里放置异步获取数据，而不用做多余的设置
			3) 在网速非常快的时候，可设置，整个数据到达Dom，更新完毕以后再渲染
			4) 在网速非常慢的时候，可设置，精确到单个组件的等待、以及更新，然后再渲染
10. 在React当中Element和Component有何区别
	+ 元素element是一个普通对象(plain object)，描述了在屏幕上呈现成什么样子。创建一个React元素element成本很低。元素element创建之后是不可变的。创建元素的话，使用React.createElement()
	+ 组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。
	+ 实例instance是你在所写的组件类component class中使用关键字this所指向的东西(组件实例)。它用来存储本地状态和响应生命周期事件很有用。函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮你做了这些。
11. 容器组件和展示组件(react-redux原理)
	+ 容器型组件
		<br>容器型组件，意为组件是怎么工作的，更具体一些就是数据是怎么更新的。它不会包含任何Virtual DOM的修改或组合，也不会包含组件的样式。如果映射到Redux上，那么容器型组件就是使用connect的组件。
	+ 展示型组件
		<br>意为组件是怎么渲染的。它包含了Virtual DOM的修改或组合，也可能包含组件的样式，同时，它不依赖任何形式的store。一般可以写成无状态函数，但实际上展示型组件并不一定都是无状态的组件，因为很多展示型组件里依然存在生命周期方法。
12. props.children
	+ props.children值有三种可能：如果当前组件没有子节点，它就是undefined；如果有一个子节点，数据类型是object；如果有多个子节点，数据类型就是array。若直接在props.children上调用map方法等，可能会出错。
	+ React提供了一系列的函数来使得操作children更加方便，如Reat.Children.map()，传递props.children时，可以保证调用方法的正常运行。
13. 路由实现原理
	+ 简单地说，路由的基本原理即是保证View和URL同步，而View可以看成是资源的一种表现。
	+ hash方式：监听window.onhashchang = function(){}
	+ broswer方式： H5的history API，history.pushState() / history.replaceState() / window.onpopstate = function(){}
14. Redux原理
	+ redux是一个针对JavaScript应用的可预测的状态管理器
15. 组件间通信
	1) 父组件向子组件通信 `props`
	2) 子组件向父组件通信 `回调函数`
	3) 跨级组件通信， `context`
	4) 没有嵌套关系的组件通信, `回调函数`(找到共同的父组件)
16. 高阶组件是什么？常见的高阶组件
	+ 高阶组件（higher-order component），类似于高阶函数，它接受React组件作为输入，输出一个新的 React 组件。
	+ Redux中的connect、 PureRender、react-roter中的withRouter
17. vue、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）
	+ jquery : dom的兼容性，简化dom的查询，ajax的封装、css动画
	+ vue/react：单页应用，移动端开发
# webpack
1. Loader
	<br>loader让webpack能够去处理那些非JavaScript文件（webpack自身只理解JavaScript）。loader可以将所有类型的文件转换为webpack能够处理的有效模块。 (import引入文件)
2. plugin
	<br>插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务
3. webpack如何做到tree shaking
	+ 移除JavaScript上下文中的`未引用代码`(dead-code)。它依赖于ES2015模块系统中的`静态结构`特性，例如import和export
	+ 新的webpack 4正式版本，扩展了这个检测能力，通过 package.json 的 "`sideEffects`" 属性作为标记，向compiler提供提示，表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。
4. webpack
	<br>本质上，webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler)。当webpack处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。
5. 打包很慢，怎么解决？
	1) 配置externals
	2) 提取css图片 公用库等
6. 打包出来的文件很大，怎么解决？
	1) 去除不必要的插件
	2) 提取第三方库
	3) 代码压缩
	4) 代码分割
	5) 设置缓存

# HTTP
1. 为什么传统上利用多个域名来提供网站资源会更有效
	1) CDN缓存更方便。
	2) 突破浏览器并发限制。
	3) Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。
2. 常见的请求头和响应头
	+ 请求头：
		<br>Accept、Host、If-Match、If-Modified-Since、If-None-Match、If-Unmodified-Since、User-Agent
	+ 响应头
		<br>ETag、Location、WWW-Authenticate、Allow、Content-Length、Content-Range、Expires、Last-Modified
3. 和缓存有关的HTTP首部字段
	<br> Cache-Control、If-Match、If-Modified-Since、If-None-Match、If-Unmodified-Since、 ETag、Expires 、Last-Modified
4. HTTP method
	<br>POST GET HEADER PUT DELETE TRACT OPTIONS
5. HTTP状态码
	+ 100 ：Continue，请求继续
	+ 200 ：Ok，请求已成功
	+ 204 ：No Content，返回的响应不包含任何实体内容
	+ 206 : Partial Content，返回部分或范围请求响应，必须包含Content-Range、Date、ETag或Conent-Loaction首部。
	+ 304 ：Not Modified，客户端发送附带条件的请求时，服务器端在满足条件的情况下允许访问资源。304状态码返回时，不包含任何响应的主体内容。
	+ 400 ：Bad Request，错误请求
 	+ 403 ：Forbidden，请求被拒绝
	+ 404 ：Not Found，请求无法找到url
	+ 500 ：Internal Server Error ，服务器内部解析错误
	+ 502 ：Bad Gateway，代理或网关响应错误
	+ 504 ：Gateway Timeout ，服务器响应超时
6. https加密过程
	+ `HTTP+加密+认证+完整性保护=HTTPS`
	+ 加密
		1) 共享密钥加密
			+ 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥加密。
		2) 使用两把密钥的公开密钥加密
			+ 公开密钥加密使用一对非对称的密钥，一把叫做私有密钥(private key)，另一个把叫做公开密钥(public key).
			+ 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。
		3) `HTTPS采用混合加密机制`
			+ 公开密钥加密与共享密钥相比，其处理速度要慢
			+ 在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。
	+ SSL客户端认证步骤
		1) 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。
		2) 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器。
		3) 服务器验证客户端证书，验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。
7. web安全
 	1) XSS，跨站脚本攻击
		+ 它允许用户将恶意代码植入到提供给其他用户使用的页面中，可以简单的理解为一种javaScript代码注入。
		+ 防御：
			1) 过滤转义输入输出
			2) 避免使用eval、new Function 等执行字符串的方法，除非确定字符串和用户输入无关。
			3) 使用cookie的httpOnly属性，加上了这个属性的cookie字段, js 是无法进行读写的。
			4) 使用innnerHTML、document.write的时候，如果数据是用户输入的，那么需要对象关键字进行过滤与转义
	2) CSRF，跨站请求伪造
		+ 其实就是网站中的一些提交行为，被黑客利用，在你访问黑客的网站的时候进行操作，会被操作到其他网站上
		+ 防御：
			1) 检测http referer是否是同域名
			2) 避免登录的session长时间存储在客户端中
			3) 关键请求使用验证码或者token机制
8. 浏览器输入网址后做了什么？
	+ 请求响应
		1) 浏览器从URL中解析出服务器的主机名
		2) 浏览器将浏览器的主机名转换成服务器的IP地址
		3) 浏览器将端口号（如果有的话）从URL中解析出来
		4) 浏览器建立一条与Web服务器的TCP连接
		5) 浏览器向服务器发送一条HTTP请求报文
		6) 服务器向浏览器回送一条HTTP响应报文
		7) 关闭连接，浏览器显示文档
	+ 浏览器解析文档
		1) 解析HTML结构生成DOM树
		2) 解析css构建css rules
		3) 解析js,然后结合DOM和css rule合成渲染树
		4) 浏览器显示页面元素
9. 域名收敛与域名发散
	1) 域名发散
		+ PC时代为了突破浏览器的域名并发限制，遵循这样一条定律：http 静态资源采用多个子域名，目的是充分利用现代浏览器的多线程并发下载能力。
		+ 各浏览器的并行连接数（同域名），最大连接数基本都是6个，IE稍显傲娇，总体而言并发数不高。所以 PC 时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源最完美地分域名存储，以提供最大并行度，让客户端加载静态资源更为迅速。
		+ 浏览器要做并发限制的根本原因，在以前，服务器的负载能力差，稍微流量大一点服务器就容易就崩溃。 所以为了保护服务器不被强暴到崩溃，浏览器要对max connections（最大并发数）进行限制。如果每个用户的最大并发数不限制的话，服务器的负载能力会大幅下降。
	2) 域名收敛
		+ 建议将静态资源只放在一个域名下面
10. SPDY协议
	+ 多路复用流
		<br>通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。
	+ 赋予请求优先级
		<br>SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
	+ 压缩HTTP首部
		<br>压缩HTTP请求和响应的首部，这样一来，通信产生的数据包数量和发送的字节数就更少了。
	+ 推送功能
		<br>支持服务器主动向客户端推送数据的功能。这样，服务器可发送数据，而不必等待客户端的请求。
	+ 服务器提示功能
		<br>服务器可以主动提示客户端请求所需的资源。由于客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。
11. CDN(Content Delivery Network，即内容分发网络)原理
	+ CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
	+ CDN的关键技术主要有内容存储和分发技术。
	+ CDN的`基本原理`是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求
12. restful （Representational State Transferg，表征状态转移）
	+ `Resources`，每一个URI代表一种资源；
	+ `Representation`，我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现
	+ `State Transfer`
		+ 如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。
		+ 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。
	+ RESTful架构：
		1) 每一个URI代表一种资源；
		2) 客户端和服务器之间，传递这种资源的某种表现层；
		3) 客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"
13. 浏览器缓存
	+ 强缓存：用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。
		+ 首部字段：expires 、Cache-Control的max-age，HTTP/1.1的max-age会覆盖掉Expires。
		+ 浏览器保存资源的最长有效时间，如果未过期，则使用客户端缓存。那么就是属于“强缓存”
	+ 协商缓存：用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。
		+ 首部字段
			1) Last-modified: 表明请求的资源上次的修改时间。
			2) If-Modified-Since：客户端保留的资源上次的修改时间。
			3) Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可）
			4) If-None-Match： 客户端保留的资源内容标识
# 性能
1. 重排，重绘，合成
	+ 从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：
		+ 解析html建立dom树
		+ 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
		+ 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
		+ 绘制render树（paint），绘制页面像素信息
	+ 浏览器会将各层的信息发送给GPU（GPU进程：最多一个，用于3D绘制等），GPU会将各层合成（composite），显示在屏幕上。
	1) 重排，重绘
		<br>当DOM的变化影响了元素的`几何属性`(宽和高)—— 比如改变边框宽度，浏览器需要重新计算元素的几何属性，同样其他元素的`几何属性`和`位置`也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为"重排(reflow)"。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为"重绘(repaint)"
	2) Composite（渲染层合并）
		<br>对页面中DOM元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。
		+ 满足以下任意情况便会创建层：
			1) 3D或透视变换(perspective transform)CSS属性
			2) 使用加速视频解码的\<video>元素拥有3D
			3) WebGL上下文或加速的2D上下文的\<canvas> 元素
			4) 对opacity做CSS动画或使用一个动画变换的元素
		+ 优点：元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。对于transform和opacity效果，不会触发layout和paint
		+ 注意点：使用3D硬件加速提升动画性能时，最好给元素增加一个`z-index`属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显
2. 前端优化方法
	1) 缓存：
		<br>ETag 、Expires、 Last-Modified 三者合用，Expires可以让浏览器完全不起Http请求，若F5发起请求，也可以通过判断`ETag`（对应浏览器字段`If-None-Match`）和`Last-Modified`（对应浏览器字段`If-Modified-Since`）字段是否需要更新资源还是使用 304(Not Modified) 的本地资源；
	2) 静态资源：
		<br>代码压缩合并、CSS雪碧图、分析 FTTB 是否采用 CDN、服务器开启 GZIP 压缩、图片压缩、静态资源使用独立域名，防止域名污染（静态资源不需要携带Cookie，又叫 Cookie 隔离）；
	3) 页面结构：
		<br>样式表放顶部，JS 脚本放底部，不让JS脚本阻碍 DOM 的加载；
	4) 代码优化：
		<br>缩短原型链，减少属性和方法的查找时间；使用事件代理代替事件绑定；减少对DOM的直接操作，减少页面重绘，按需加载、条件预加载、延迟加载；
3. requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：
	1) requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
	2) 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。
4. 页面性能
	+ 白屏时间（first Paint Time）——用户从打开页面开始到页面开始有元素呈现为止。一般认为浏览器开始渲染\<body>标签或者解析完\<head>标签的时刻就是页面白屏结束的时间点
	+ 首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间。通常5秒以内是优秀，10秒以内是可以接受，10秒以上不可忍受。
	+ 用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作
	+ 总下载时间——页面所有资源都加载完成并呈现出来所花的时间，即页面onload的时间

# 其他问题
1. babel原理
	+ babel是一个转译器，感觉相对于编译器compiler，叫转译器transpiler更准确，因为它只是把同种语言的高版本规则翻译成低版本规则
	+ babel工作分为三个阶段:
		1) parsing(解析): 将高版本的代码(es6/7)解析构建抽象语法树
		2) transforming（转译）:将抽象语法树进行遍历转译，得到新的AST树
		3) generating(生成)：把抽象语法树再生成低版本如(es5/es3)代码字符串
2. 常见算法
	1) 冒泡排序
		+ 算法描述：
			+ 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
			+ 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
			+ 针对所有的元素重复以上的步骤，除了最后一个；
			+ 重复步骤1~3，直到排序完成。
		```javascript
		function bubbleSort(arr) {
		  for (let i = 0, l = arr.length; i < l - 1; i++) {
		    for (let j = 0; j < l - 1 - i; j++) {
		      if (arr[i] > arr[j]) {
		        let tem = arr[i];
		        arr[i] = arr[j];
		        arr[j] = tem;
		      }
		    }
		  }
		  return arr;
		}
		```
	2) 选择排序
		+ 算法描述：
			+ 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
			+ 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
			+ 以此类推，直到所有元素均排序完毕。
		+ 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。
		```javascript
		function selectSort(arr) {　　
		  var minIndex, temp;　　
		  for (var i = 0, len = arr.length; i < len - 1; i++) {
		    minIndex = i;　　　　
		    for (var j = i + 1; j < len; j++) {
		      if (j >= 0 && arr[j] < arr[minIndex]) {
		        minIndex = j;
		      }
		    }　　　
		    temp = arr[i];　　　　
		    arr[i] = arr[minIndex];　　　　
		    arr[minIndex] = temp;　　
		  }　　
		  return arr;
		}
		```
	3) 插入排序
		+ 算法描述：
			+ 从第一个元素开始，该元素可以认为已经被排序；
			+ 取出下一个元素，在已经排序的元素序列中从后向前扫描；
			+ 如果该元素（已排序）大于新元素，将该元素移到下一位置；
			+ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
			+ 将新元素插入到该位置后；
			+ 重复步骤2~5。
		```javascript
		function insertSort(arr) {
		  for (var i = 1, len = arr.length; i < len; i++) {
		    var key = arr[i];
		    var j = i - 1;
		    while (arr[j] > key) {
		      arr[j + 1] = arr[j];
		      j--;
		    }
		    arr[j + 1] = key;
		  }
		  return arr;
		}
		```
	4) 快速排序
		+ 算法描述：
			+ 取出数组元素的中间值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，
			+ 递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。
		```javascript
		function quickSort(arr) {
		  var len = arr.length
		  if (len <= 1) {
		    return arr;
		  }
		  let leftArr = [];
		  let rightArr = [];
		  let i = Math.floor(len / 2)
		  let mid = arr.splice(i, 1);
		  for (let i = 0; i < len - 1; i++) {
		    if (arr[i] > mid) {
		      rightArr.push(arr[i]);
		    } else {
		      leftArr.push(arr[i]);
		    }
		  }
		  return [].concat(quickSort(leftArr), mid, quickSort(rightArr));
		}
		```
	5) 归并排序
		+ 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。
		```javascript
		function mergeSort(arr) { //采用自上而下的递归方法
		  var len = arr.length;
		  if (len < 2) {
		    return arr;
		  }
		  var middle = Math.floor(len / 2),
		    left = arr.slice(0, middle),
		    right = arr.slice(middle);
		  return merge(mergeSort(left), mergeSort(right));
		}
		function merge(left, right) {
		  var result = [];
		  while (left.length && right.length) {
		    if (left[0] <= right[0]) {
		      result.push(left.shift());
		    } else {
		      result.push(right.shift());
		    }
		  }
		  return result.concat(left).concat(right)
		}
		```
		+ 迭代法实现
		```javascript
		function mergeSort(arr) {
		  var len = arr.length;
		  if (len < 2) {
		    return arr;
		  }
		  var work = []
		  for (var i = 0; i < len; i++) {
		    work.push([arr[i]])
		  }
		  work.push([])  // 如果数组长度为奇数
		  for (var lim = len; lim > 1; lim = (lim + 1) / 2) {
		    for (var j = 0, k = 0; k < lim; j++, k += 2) {
		      work[j] = merge(work[k], work[k + 1])
		    }
		    work[j] = [] // 如果数组长度为奇数
		  }
		  return work[0]
		}
		```
	6) 数组乱序(快速洗牌法)
		```javascript
		function shuffe(arr) {
		  var len = arr.length
		  if (len <= 1) {
		    return arr;
		  }
		  for (let i = 1; i < len; i++) {
		    var j = parseInt(Math.random() * (len - 1))
		    var tem = arr[j]
		    arr[j] = arr[len - 1 - i]
		    arr[len - 1 - i] = tem
		  }
		  return arr
		}
		```
	7) 数组去重
		```javascript
		let unique = function(arr) {
		  let hashTable = {};
		  let data = [];
		  for (let i = 0, l = arr.length; i < l; i++) {
		    if (!hashTable[arr[i]]) {
		      hashTable[arr[i]] = true;
		      data.push(arr[i]);
		    }
		  }
		  return data
		}
		```
	8). 两个有序序数组的中位数
		<br>题目描述：给定两个大小为 m 和 n 的有序数组nums1和nums2。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。
		<br>示例1：nums1 = [1, 3]， nums2 = [2] 中位数是 2.0
		<br>示例 2: nums1 = [1, 2]，nums2 = [3, 4]，中位数是 (2 + 3)/2 = 2.5
		```javascript
		function findMedianSortedArrays(nums1, nums2) {
		  var result = []
		  while (nums1.length > 0 && nums2.length > 0) {
		    if (nums1[0] < num2[0]) {
		      result.push(nums1.shift())
		    } else {
		      result.push(nums2.shift())
		    }
		  }
		  var res = result.concat(nums1).concat(nums2)
		  var middle = Math.floor(res.length / 2)
		  if (res.length % 2) {
		    return res[middle]
		  } else {
		    return (res[middle - 1] + res[middle]) / 2
		  }
		}
		```
	9). 不借助临时变量，进行两个整数的交换: 输入 a = 2, b = 4 输出 a = 4, b =2
		```javascript
		//主要是利用 + – 去进行运算，类似 a = a + ( b – a)实际上等同于最后的a = b;
		function swap(a, b) {
		  b = b - a;
		  a = a + b;
		  b = a - b;
		  return [a, b];
		}
		```
	10) 两大数相加
	```javascript
	function sumStrings(a,b){
    var res='', c=0;
    a = a.split('');
    b = b.split('');
    while (a.length || b.length || c){
      c += ~~a.pop() + ~~b.pop();
      res = c % 10 + res;
      c = c>9;
    }
    return res.replace(/^0+/,'');
	}
	```
3. 前端异常监测如何实现

# node
1. Buffer模块是干什么的
2. Stream是什么，使用的两种模式
3. http模块如何将异步处理方式实现成同步处理方式，具体解析请参考http模块如何将异步处理转成同步处理
