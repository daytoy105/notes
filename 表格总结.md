# React技术栈项目升级总结
### React的升级(React 15.6 -> React 16+)
|    　　　　|   React V15       |     React V16      |
| ----------|------------------|-------------------|
| 生命周期 | | |
| Mounting | constructor() -> componentWillMount() -> render() -> componentDidMount() | constructor() -> getDerivedStateFromProps(props, state) -> render() -> componentDidMount() |
| Updating | componentWillReceiveProps(nextProps) -> shouldComponentUpdate(nextProps, nextState) -> comppoentWillUpdate(nextProps, nextState) -> render() -> componentDidUpdate(prevProps, prevState)  | getDerivedStateFromProps(props, state) -> shouldComponentUpdate(nextProps, nextState) -> render() -> getSnapshotBeforeUpdate(prevProps, prevState) -> componentDidUpdate(prevProps, prevState, snapshot)|
| Unmounting | componentWillUnmount()  | componentWillUnmount() |
| context  | 父：getChildContext() <br>  子：this.context.name  |  父：this.TContext = React.createContext() ，\<TContext.Provider/> <br>子 ： \<TContext.Comsumer /> |
| ref      | 字符串：this.refs.name <br> 回调函数  | 取消字符串的方式<br> 创建：this.myRef = React.createRef() <br> 获取DM：this.myRef.current <br> `转发ref`：React16以前，ref不是能向下传递的。React 16新增`forwardRef` |
| render()  |  React elements <br> Boolean和null | 新增加三种类型: <br> Array和Fragment <br> String和number <br> Portals |
| ReactDOM  | render() <br> findDOMNode() <br> unmountComponentAtNode()   |新增两个方法：<br> hydrate() <br> createPortal() |
___
### React-Router( V2 -> V4)
|    　　　　| React-Router V2 | React-Router V4 |
| ----------|------------------|------------------|
| `<Router>`<br>`<Route>`标签| 引入：import { Router, Route, IndexRoute, hashHistory } from 'react-router'<br> `<Router>`可有多个子节点\<Route> | V4 将react-router-dom拆分 <br> 引入：import { HashRouter as Router, Route } from 'react-router-dom';<br> `<Router>`只能有一个子节点\<Route>，多个需要用\<div>包裹 |
| 嵌套路由 |  `<Route>`标签嵌套`<IndexRoute>`、`<Route>`实现  | V4 中已经没有`<IndexRoute>`了，但可以使用`<Route exact>`来达到同样的效果<br> `<Switch>`来启用排他路由, 只需要在路由列表里匹配一个路由 <br> `<Route>`的render props方式嵌套路由 |
| 路由出口 | this.props.children | 没有，直接都是组件|
| props.params | this.props.params.paramName | this.props.match.params.paramName|
| location.query | this.props.location.query | V4 去掉了location.query，只能使用search来获取，为了让其跟浏览器一样。<br> this.props.location.search |
| 路由跳转 | 通过context: <br> static contextTypes:{router: PropTypes.object}<br> this.context.router.push(path)  | this.props.history.push(path) <br> 组件若不是由\<Route>直接渲染的，可以使用`withRouter()`高阶组件获取history对象 |
| Link 和 activeClassName | 引入：import { Link } from 'react-router' <br> 使用：\<Link to="/about" activeClassName="active">About\</Link> | 引入：import { Link} from 'react-router-router' <br>`<Link>`不再支持 activeClassName, 改为`<NavLink>` <br> \<NavLink to="/about" activeClassName="active">About\</NavLink> |
| 路由勾子 |  onEnter、onUpdate、 onLeave | V4 中去掉了on****的路由生命周期的钩子，<br>componentDidMount()或componentWillMount()代替onEnter，<br>componentWillUpdate()或componentWillReceiveProps()代替onUpdate，<br>componentWillUnmount()代替onLeave
| 小结  | V2 路由集中在一个地方。布局和页面嵌套是通过\<Route>组件的嵌套而来的。布局和页面组件是完全纯粹的，它们是路由的一部分。| V4 不再主张集中式路由了。相反，路由规则位于布局和UI本身之间 |
_________

### webpack 配置  (webpack V1 -> V2 -> V4)
|     | webpack V1 | webpack V2 | webpack V4 |
|-----|------|------|------|
| webpack依赖 | webpack  |  webpack |  webpack 、 webpack-cli |
| 环境定义 | 1. 传递: package.json的script中配置启动命令，{"dev": "set NODE_ENV=development&& webpack-dev-server --config webpack.config.js --port 80"} <br> 2. 获取： process.env.NODE_ENV <br>3. 插件：DefinePlugin <br>new webpack.DefinePlugin({'process.env': {'NODE_ENV': JSON.stringify(nodeEnv)}}) | 同 V1 | 移除DefinePlugin，module.exports配置mode |
| 代码压缩 | UglifyJsPlugin | UglifyJsPlugin | 默认生产环境压缩，需要指定wepack环境`mode` |
| loader的配置 |  module.loaders  | module.rules | 同 V2 |
| 提取第三方库 | CommonsChunkPlugin 、entry配置vendors, 指定需提取的文件 | CommonsChunkPlugin (配置manifest、vendors) | SplitChunksPlugin(公共文件js/css)、<br>RuntimeChunkPlugin |
| 提取css文件 | extract-text-webpack-plugin(外), module.loaders配置提取css | plugin与 V1 相同，module.rules提取css | 1. mini-css-extract-plugin(外), module.rules配置提取css, 需注意css中背景图片的路径, SplitChunksPlugin(合并提取的css文件)<br> 2. extract-text-webpack-plugin@next, 同extract-text-webpack-plugin的配置 |
| css自动补全 | `autoprefixer` 、`postcss-loader`，module.exports配置postcss | plugins相同，webpack.LoaderOptionsPlugin配置postcss | plguins相同，loaders的options配置或postcss.config.js |
| 动态路由 | react-router V2、 react 15.3.1、 add-module-exports ，require.ensure()方式| react-router V4 、 react 15.6.x，import()方式 | 同 V2 |
____



# 基础技能总结
## webpack4.x
### loaders
| 功能 | loader |
|------|-------|
| 加载css | style-loader、css-loader |
| 加载sass | node-sass、sass-loader |
| css自动补全 | postcss-loader(在css-loader之后，预编译之前)、autoprefixer(指定版本)<br>使用：1. 模块导出  2. options配置<br> plugins: [require("autoprefixer")({ browsers: ['last 2 versions'] })]|

### plugins
| 功能 | plguins |
|-----|----------|
| CDN引入外部文件 | html文件引入需加载的文件，webpack配置externals |
| 提取模板文件 | new webpack.optimize.SplitChunksPlugin() <br>new webpack.optimize.RuntimeChunkPlugin() |
| 提取css文件 | 1. mini-css-extract-plugin (需注意css背景图片路径) <br>rules配置: [{loader: MiniCssExtractPlugin.loader,options: {publicPath: './' }},{loader: "css-loader"}, {loader: "postcss-loader",},{loader: "sass-loader"}]<br>优点：异步；使用预加载或内联css；能根据入口名提取(用于动态路由)<br> 2. extract-text-webpack-plugin@next <br>rules配置: ExtractTextPlugin.extract({fallback: "style-loader", use: ['css-loader',"postcss-loader", 'sass-loader']}) |
| 生产环境压缩 | 默认开启压缩，需指定webpack运行环境，mode |
| tree shaking | 移除JavaScript上下文中的未引用代码(dead-code)<br> 需要在package.json中配置`sideEffect`, 如果所有代码都不包含副作用，可属性标记为`false`; 有副作用的文件需单独列出，如css, "sideEffect":["*.css"]
| 生成模板文件 | html-webpack-plugin <br> 使用：new HtmlWebpackPlugin()<br>多入口页面时，需要多次调用, chunks指定引入html的入口配置 |
| 清除`/dist`文件夹 | clean-webpack-plugin <br> 使用：new CleanWebpackPlugin(['dist'])<br>容易造成文件夹访问权限问题(冲突？)  |
| 热替换 | 1. webpack-dev-server <br> 2. webpack-dev-middleware + webpack-hot-middleware + express <br> **重点**`publicPath`的配置 |
| 自动打开浏览器 | open-browser-webpack-plugin <br>new OpenBrowserPlugin({url: 'http://localhost:80/dist/#/'}) |
| hash | hash一般是结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值<br>1. 采用`hash`计算的话，每一次构建后生成的哈希值都不一样，即使文件内容压根没有改变。这样子是没办法实现缓存效果，我们需要换另一种哈希值计算方式，即chunkhash <br> 2. `chunkhash`和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动`公共库`的代码，就可以保证其哈希值不会受影响 <br>3. mini-css-extract-plugin的`chunkhash`(extra-text-webpack-plugin@next里的`contenthash`值)，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建。<br>4. 热更新(HMR)不能和[chunkhash]、[contenthash]同时使用|
| 模块标识符 | 1. NamedModulesPlugin <br>`[hash]` 当开启HMR的时候使用该插件会显示模块的`相对路径`，建议用于开发环境。<br> new webpack.NamedModulesPlugin() <br> 2. HashedModuleIdsPlugin <br>`[chunkhash]`推荐用于生产环境构建 <br>使用：new webpack.HashedModuleIdsPlugin() |
___________

## babel
| loader | 功能 |
|-----|-----|
| babel-core | |
| babel-loader | |
| babel-plugin-import | |
| babel-plugin-transform-decorators-legacy | |
| babel-plugin-transform-runtime | |
| babel-preset-env | |
| babel-preset-react | |
| babel-preset-stage-2 | |
____

## Vue 技术栈 vs **React 技术栈**
### 基础比较
| 功能   |  vue  |  react  |
|-----|-------|-----|
| 简介 | 1.在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。<br> 2. vue.js采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调  <br> 3. 每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。| 1. React并不是完整的MVC/MVVM框架，它`专注`于提供清晰、简洁的`View（视图）`层解决方案。而又与模板引擎不同，React不仅专注于解决View层的问题，又是一个包括View和Controller的库。对于复杂的应用，可以根据应用场景自行选择业务层框架，并根据需要搭配React-Router、Redux等来使用 <br> 2. 基于React进行开发时，所有的DOM树都是通过`Virtual DOM`构造的。React在Virtual DOM上实现了DOM diff算法，当数据更新时，会通过diff寻找到需要变更的DOM节点，并只对变化的部分进行实际的浏览器的DOM更新，而不是重新渲染整个DOM树。<br> 3. react的另一个精髓是`函数式编程`，React在设计时带有函数式编程的基因，因为React组件本身就是纯函数，React的`createElement`方法保证了组件是纯净的，即传入指定props得到一定的Virtual DOM，整个过程都是可预测的。包括redux的体现了函数式编程的语法特点， state状态的改变只能通函数来实现,中间件的实现 |
| 版本 | 1. 如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版。<br>2. 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。<br>3. 因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。如果你仍然希望使用完整版，则需要在打包工具里配置一个别名 | 1. react + react-dom is 109 kb (34.8 kb gzipped), down from 161.7 kb (49.8 kb gzipped)<br>比Reat V16之前的版本减少了约32%，主要体现支持自定义属性，减少了属性的白名单，采用roll up构建 |
| webpack 配置 | 1. 所需的额外插件： vue-template-compiler 、vue-loader <br> 2. 使用：const {VueLoaderPlugin} = require('vue-loader'); <br> plguins : [new VueLoaderPlugin()] <br> 3. vue的完整版本的别名配置：resolve:{ alias:{ 'vue$': 'vue/dist/vue.esm.js'}} | 1. 所需的额外插件：babel-preset-react、babel-plugin-transform-decorators-legacy |
| 创建实例 | new Vue({el:'#app'}) <br> new Vue({router}).$mount('#app') | ReactDOM.render(element, document.getElementById('app'))  |
| 基础使用 |
| 数据 | 1. {{name}}, state是可变的，修改方式`this.name=''`<br> 2. computed: 计算属性是基于它们的依赖进行`缓存`的 <br> 3. methods：方法是`不缓存`的，响应变化，每次调用<br> 4. watch: 当需要在数据变化时执行异步或开销较大的操作时，响应数据的变化　| `{data}`，state是不可变的，修改方式`setState()` <br>`setState()`在实现上主要有两个方法，enqueueSetState()和performUpdateIfNecessary()，调用setState()之后，首先会执行enqueueSetState()方法，进行state的合并，通过enqueueState()进行state的更新，此时_pendingStateQuene的值不为空，所以performUpdateIfNecessary()会调用updateComponent()，updateComponent()自身会调用shouldComponentUpdate()和componetWillUpdate()方法，所以这也是不能在这两个方法上调用setState()的原因，会形成循环调用导致程序崩溃。通过触发re-render()，在这个过程中，高效的dom diff算法能高效的寻找到需要变更的DOM节点，并只对变化的部分通过pacth()转化为真实dom，渲染输出在浏览器上。|
| 条件渲染 | 1. v-if / v-else <br> \<span v-if="ok">Yes\</span>  <br> 2. v-show: 相当于display的切换 <br>v-if有更高的切换开销，而v-show有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好 | js 条件语句 <br>　{ ok ? \<span>\</span> : null } <br> 2.css的display |
| 列表渲染 | v-for, `item`、`index`、`key` <br>属性动态绑定：v-bind, `:` <br> 可配合v-if使用 | map() , 添加 key |
| 插入html | \<span v-html="rawHtml">\</span>  | \<span dangerourslySetInnerHTML={{__html:rawHtml}}>\</span>
| 访问DOM元素 | 1. 访问根实例`$root` <br> 2. 访问父组件 `$parent` <br> 3. 访问子组件实例, 组件定义ref属性，字符串形式，调用：`this.$ref.xxx`<br> 4. 依赖注入：嵌套组件(多)的情况,使用` provide`、`inject` | 1. 访问组件实例 <br>this.myRef = React.createRef() <br> 回调函数 <br> React 17 取消字符串形式<br> 2. 向子组件传递ref: forwardRef() <br> 3.嵌套组件(多)的传递, `context` <br> const TContext = React.createContext(), `<TContext.Provider>`、`<TContext.Comsumer>` |
| css |
| class样式 | 外部文件引入<br> 模板内部 \<lang scoped > , `scoped` 局部 <br> \<a class = '{ active: isActive }' /> ，多个动态class，数组形式 | 外部文件引入 <br> \<a className={`${isActive?'active':''}`} /> ，自由扩展 |
| 过渡、动画 |`<transition name="fade">` <br> 1. 过渡的类名(`v`为name的值): v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to <br>| |
| 事件 |
| 原理 | 所有的Vue.js事件处理方法和表达式都严格绑定在当前视图的ViewModel上，当一个ViewModel被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们 | react并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的`最外层`，使用一个统一的`事件监听器`，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。<br>当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升 |
| 事件绑定 | v-on，`@` <br> 使用：\<span @click="handleClick($event)" >\</span> <br> 获得对象： $event <br> 方法不能写成箭头函数形式(this为undefined), 普通方法this指向vue实例  <br> | \<span onClick={this.handleClick.bind(this)}>\</span> <br> 需手动绑定this |
| 事件修饰符 | stop、prevent、capture、self、once、passive <br> | 没有修饰符， 阻止事件默认行为，evnet.preventDefault() |
| 传递原生事件 | 1. 事件修饰符 native，缺点：传递在直接根节点下，若根节点没有这个原生事件，则不会被触发。<br> 2. Vue的`$listeners`属性, 可以指定在需要的节点上，合并所有的事件：Object.assgin或对象扩展 | |
| 表单 | `v-model`: 双向绑定 (value/input结合), 根据控件类型自动选取正确的方法来更新元素<br>忽略所有表单元素的 value、checked、selected特性的初始值而总是将Vue实例的数据作为数据来源 <br> 组件中使用v-model，单选、复选等类型需要额外声明避免冲突,`model`属性解决 <br> model:{prop:'checked',event:'change'} <br>子：value需在props中指定，template中需要显式定义value，input <br> 父：\<blog v-model=""/> <br> 4. 修改符`sync` , props的单向绑定 | 1. 受控组件, `value` / `checked` , `onChange()` <br> 2. 非受控组件, `ref`、`defaultValue`|
| 生命周期 | `beforeCreate()`: 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。<br> `created()`: 在实例创建完成后被立即调用。<br> `beforeMount()`: 在挂载开始之前被调用<br> `mount()`: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 <br> `beforeUpdate()`: 数据更新时调用，发生在虚拟 DOM 打补丁之前。`update()`: 当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于 DOM 的操作<br> `beforeDestroy()` : 实例销毁之前调用。在这一步，实例仍然完全可用。<br> `destroyed()`: Vue 实例销毁后调用。<br> `errorCaptured()`: 错误捕获 | 1. `mounting`: constructor() -> static getDerivedStateFromProps(props, state ) -> render() -> componentDidMount() <br> 2. `updating`: static getDerivedStateFromProps(props, state) -> shouldComponentUpdate(nextProps, nextState) -> render() ->  getSnapshotBeforeUpdate(prevPorps, prevState) -> componentDidUpdate(prevProps, prevState, snapshot) <br> 3. `unmounting`: componentWillUnmount() <br> 4. `error`: componentDidCatch(error, info), `react 16.6的新的错误处理方法`， getDerivedStateFromError(error) <br> 5. UNSAFE_componentWillMount()、UNSAFE_componentWillReceiveProps(nextProps)、UNSAFE_componentWillUpdate(nextProps, nextState)这三个方法标记为不安全方法。 <br> 服务器端渲染时，只调用componentWillMount() |
| 组件 |
| 创建语法 | Vue.component()、Vue.extend()| es6 class / function() |
| 组件使用 | 1. 全局注册，需要在vue实例创建之前发生<br> 2. 局部注册，components属性中指定使用的组件名 <br> 3. 字符串 (例如：template: '...') <br> 4. 单文件组件 (.vue) 5. \<script type="text/x-template"> | 1. 组件直接嵌套<br>2. 高阶组件 @Hoccomponent <br>3. React.createElement() <br> 4. React.createPortal() |
| 向子组件传递数据 | props：1. props单向下行绑定 <br> 2. 使用字符串`静态`传递时，在JS中是camelCase，在Html中是kebab-case <br>3. 动态传递v-bind, 为js表达式,可以是数字、变量、对象等,<br> v-bind="obj"// 传递obj的所有属性 <br> 4. props验证，属性有type、required、default、validator<br> 父：\<blog post-value='Vue'/>  <br>子：props:['postValue'] | props : 1. 自顶而下，单向流动<br> 2. 传递的类型可以是任何类型, 形式为 name={obj}, 或 {...obj} <br>3. props验证, props-type (import) <br> 父: \<component title="name" /> <br>子：this.props.title |
| 事件向父级组件发送消息| 子：$emit('事件名', params)  <br> 父：组件用`v-on`监听的事件名, $event: 指向参数 <br> 子：template:'<p @click="$emit('pclick','333')">\</p>'  <br> 父：\<blog @pclick="child=$event"> | 回调函数、props <br> 父: \<component save = {(value)=>this.handleSave(value)} > <br> 子: this.props.save('haha') |
| 动态组件 | \<component :is="alive" /> | render props 动态渲染组件 |
| 缓存组件 | \<keep-alive> | 生命周期+sessionStorage实现组件缓存 |
| 组件过渡 | \<transition> <br> \<transition-group> |  |
| 向组件传递内容 | \<slot>, 还可以在节点或模板中定义slot属性，指定位置插入内容 | this.props.children |
| 混入 | `mixins`属性<br>1. 数据对象：在内部进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以`组件数据优先`<br> 2. 生命周期钩子：同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。<br>3. 普通函数：两个对象键名`冲突`时，取`组件对象`的键值对<br> 全局混入：` Vue.mixin()`| 高阶组件， decorator |
| 优化 | 1. \<keep-alive> 缓存组件 <br> 2. 通过v-once创建低开销的静态组件  |  |
| 测试 | vue-test-utils | react-test-util、Jest、enzyme |
|  相同点 | 利用虚拟DOM实现快速渲染， 轻量级，响应式组件，服务器端渲染，易于集成路由工具，打包工具以及状态管理  |

### 路由比较
| 功能 | Vue-Router | React-Router |
|-----|---------|----|
| 原理 | |  |
| 路由挂载 | 1.引入文件：vue、vue-router <br> 2. Vue.use(VueRouter) <br> 3. 路由配置：const routes = [{ path:'/', component:Index},{ path:'/about', component:About}] <br> 4. 创建路由实例：const router = new Router({routes}) <br> 5. router 注入: const app = new Vue({router}).\$mount('#app'); <br> 6. 访问：` this.$router` | 1. 引入文件： react-router-dom <br> 2. 定义路由组件： const MyRouter = \<Router>\<div>\<Route path="/" component="Index" />\<Route path="/about" component="About" />\</div>\</Router> <br> 3. 挂载路由：ReactDOM.render(\<MyRouter />,document.getElementById('app')) <br> 4. 访问：`this.props` |
| 路由出口 | `<router-view>` | 路由即组件 |
| 嵌套路由 | 1. 路由配置的参数 `children`属性 <br> 2. 嵌套出口: `<router-view>` | `<Route>`的render props方式嵌套路由 |
| 导航标签 | 1. `<router-link>` <br> 2. 高亮：`router-link-active`， class样式值 | 1. `<Link>`、`<NavLink >`<br> 2. 高亮：`activeClassName`, NavLink标签属性 |
| 路由参数 | this.$router.params | this.props.match.params |
| 查询参数 | this.$route.query | this.props.location.search |
| 参数变化 |1. watch: {'$route' (to, from) {// 对路由变化作出响应...}} <br> 2. beforeRouteUpdate (to, from, next) | 生命周期函数 <br> componentWillReceiveProps(nextProps) <br> componentDidUpdate(prevProps, prevState) <br> getDerivedStateFromProps(props,state) |
| 路由跳转 | 1. 标签：属性`to` <br> 2. 函数：this.$route.push() <br> 3.`path`, 字符串或对象。{path:'',query:''},{name: '', params:''}, **path会忽略params属性** | 1. 标签：属性`to` <br> 2. 函数：this.props.history.push(path) <br> 3. 组件若不是由\<Route>直接渲染，可以使用`withRouter()`高阶组件获取history对象 <br> 4. `path` 字符串|
| 路由别名 | `alias` 自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构 | |
| 路由组件传参 | `props`对象配置 | 自定义传参属性 |
| 路由钩子 | 1. 全局：beforeEach(to, from, next) afterEach(to, from) <br>2. 路由内部: beforeEnter(to, from, next) <br> 3. 组件：beforeRouteEnter(to, from, next)、 beforeRouteUpdate(to, from, next)、beforeRouteLeave(to, from, next)| 同组件生命周期 |
| 路由元信息 | 路由参数`meta`属性 ,访问：`$route.matched`| |
| 数据获取 | 1. 导航完成后获取数据: <br>  1) 组件的`created()`获取数据 <br>  2) watch监听路由变化`'$route'`获取数据的方法 <br> 2. 在导航完成前获取数据: <br>  1) beforeRouteEnter()获取数据，成功后调用next() <br>  2) 路由变化后更新: beforeRouteUpdate()  | 1. 初始化获取数据:componentDidMount() <br> 2. 路由变化后更新数据 componentDidUpdate(prevPorps, prevState) |
| 滚动行为 | 当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样<br> `路由实例`配置`scrollBehavior`  | |
| 路由懒加载 | import() | 相同 |

### 状态管理
|  功能   | Vuex | Redux |
|-----|---------|----|
| 原理 | 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br> 把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。| 应用中所有的state都以一个对象树的形式储存在一个单一的store中(调用createStore(reducers,initialState, middlewares)), 通过action的调用来改变state, 在reducers中根据action和state返回新的state的值|
| 全局注册 |1. 引入文件 vue、vuex  <br> 2. Vue.use(Vuex) <br> 3. 实例化: const store = new Vuex.Store() <br> 4. 注册store：const app = new Vue({store}).\$mount('#app'); <br> 5. 访问：全局：`store`, 注入后：`this.$store` | 1. 引入`react-redux`、`redux` <br>2. 创建store: const store = createStore(initialState, reducers, applyMiddleware) <br> 3. 挂载：ReactDOM.render(\<Provider store={store}>\<App/>\</Provider>,document.getElementById('app')) <br>4. 访问：高阶组件`connect()`，connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])  |
| 核心store | const store = new Vuex.Store() | const store = createStore(reducers, applyMiddleware) |
| 全局初始化状态 |1. 全局根实例`store`, 导致组件依赖全局状态单例 <br> 2. store 注入的方式： this.$store.state 或 `mapState()` <br>...mapState({count: state=> state.count }) | state |
| state数据处理 | getters对象 <br>定义: 接收(state [,getters]) 参数 <br>访问: $store.getters 或者 mapGetters() <br> **getter 在通过方法访问时，每次都会进行调用，而不会缓存结果** | 直接在reducer中处理，(state, action)=>state |
| 同步 | 1. mutaions对象中配置相应的方法 <br> 2. 触发：this.$store.commit() 或 mapMutations() | dispath 自身只处理同步事件, store.dispath({type:'Action Name',data}) <br>使用: 集中配置actions <br> 2. 引入所需的actions， 组件内借助connect()访问 state, action，`this.props` |
| 异步 | actions对象 <br> 2. 触发：this.$store.dispatch() 或 mapActions() | 引入redux-thunk，增强dispatch，处理异步actions。<br>`redux-thunk`在实现上，首先检查参数action的类型，如果是函数，就执行action这个thunk函数，并把dispatch，getState，外部参数等传递进去处理，否则就调用next()方法继续处理action。 redux-thunk中间件，返回的可能是一个action函数，也可能是上一个中间件的返回结果。|
| 插件 | `store实例`配置plugins | `applyMiddleware()`, 核心实现是compose()，通过将不同的middlwares一层一层包裹到原生的dispatch之上，然后对middleware的设计采用柯里化, 以便于compose。compose()将chain中的所有匿名函数通过调用reduce()，从右到左依次组合得到增强后的dispatch。<br> 中间件的执行顺序：`外层先进入，内层先执行` |
| 与vue/react的结合 | 与vue的结合，通过Vue.use(vuex)，在vue中挂载插件的方式 | 通过react-redux与react结合，原理是容器组件与展示组件的思想，提供了\<Provider>和connect()。\<Provider>作为顶层组件，接收store并通过context传入所有的子组件上的connect()。<br>`connect()`是一个高阶组函数，首先传入mapStateToProps, mapDispatchToProps等参数，然后返回一个接收component参数的函数wrapWithConnect()，函数中接收了store中的值，并调用shouldComponetUpdate()进行页面优化，最终返回一个增强的高阶组件 |

### UI
|     | antd-design | elements-ui|
|-----|---------|----|
| 原理 | | |
____

## 网络
### http请求
|     | 用法 |优点   |  缺点 |
|--------|---------|----|----|
| ajax | xhr = new XMLHttpRequest(); <br>进度事件：onprogress、loaded、total | | |
| fetch |`whatwg-fetch`<br> let res = await fetch(url) // res是未处理对象集合，若需要json格式，需要执行`res.json()`| 1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里<br> 2. 更加底层，提供的API丰富（request, response）<br>3.支持JSONP，引入`fetch-jsonp` | 1. fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 <br> 2. fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行<br> 3. fetch没有办法原生监测请求的进度，而XHR可以 |
| axios | let res = await axios(url) //res是响应结果}) | 1.从node.js创建http请求 <br>2.支持Promise API <br>3.转换请求和响应数据<br> 4. 取消请求 <br>5. 自动转换JSON数据<br> 6.客户端支持防止CSRF/XSRF | 不支持JSONP |
| jq ajax | $.get(url) | 基于原生的XHR开发 | JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理 |

### 跨域
+ 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源
+ 通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。

|  方法  | 用法及其优缺点 |
|-----|------|
| cors | CORS(Cross-Origin Resource Sharing, 跨源资源共享),背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。<br> 服务器如果认为这个请求可以接受，就在`Access-Control-Allow-Origin`头部中回发相同的源信息(如果是公共资源，可以是`'*'`) |
| jsonp | 主要是利用script标签src属性不受同源策略限制的特性，向跨域的服务器请求并返回JSON数据。<br>JSONP由两部分组成: 回调函数和数据。回调是当响应来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。<br> `优点`在于能够直接访问响应文本，支持在浏览器与服务器之间的双向通信 <br>`缺点` 1. 安全性, 如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究 2. 要确定JSONP请求是否失败并不容易 3. 只能发送GET请求|
| 图像ping | (new Image()).src='xxxx' <br>`优点`：所有浏览器都支持Image对象，包括那些不支持XMLHttpRequest对象的浏览器; 性能消耗很小，而且服务器的错误完全不会影响到客户端。<br>`缺点` 一是只能发送GET请求，二是无法访问服务器的响应文本。因此，图像Ping只能用于浏览器与服务器间的单向通信|
| document.domain | 通过设置相同的域实现 <br>缺点：只适合主域相同但子域不同的情况 |
| postMessage() | window方法，允许非同源脚本调用，该方法允许有限的通信，通过`异步消息传递`的方式，在来自不同源的脚本之间`跨文档消息传递`。<br> 接收两个参数：<br>第一个是消息传递内容，可以是任意基本类型和可以复制对象,对于可以接收字符串的，应使用JSON.stringify()序列化。<br>第二个参数是指定的窗口的源。（协议，主机名，端口）。`'*'` 表示传递给任意窗口，`'/'` 表示当前窗口和指定窗口同源<br> message事件，拥有三个事件对象: data、source、origin |
| websocket | WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。 <br> 缺点： 兼容性 |
____


### KOA vs Express
|  功能  | Express | Koa 2.x |
|-----|---------|----|
| 特点 | Express相对大而全，API较为丰富的框架，并且它的整个中间件模型是基于callback回调 | Koa是运行在Node.js中的web服务框架，小而美。 <br>`Koa1`基于co管理 Promise/Generator中间件 <br>`Koa2`紧跟最新的ES规范，支持到了Async Function |
| 中间件 |  | 执行顺序： 由最外层开始进入，遇到next()方法，暂时执行这个中间件，进入下一个中间件执行，直接没有next()，然后开始逆顺执行，一直到最外层。 |

_________


### css预处理器
|   | 用法  | 优点 | 缺点 |
|-----|-------|----------|-----------|
| Sass |  | | |
| Less | | | |

### highcharts
____
### 移动端页面框架
|          | 用法 | 优点 | 缺点 |
| -------- | ---- | ---- | ---- |
| fullpage |      |      |      |
| zepto    |      |      |      |
| swiper   |      |      |      |

### 包管理器
|   | 用法  | 优点 | 缺点 |
|-----|-------|----------|-----------|
| npm | 1. 淘宝镜像：npm install -g cnpm --registry=https://registry.npm.taobao.org  <br> 2.npm  -D/save --dev : 保存在devDependencies <br>npm save: 保存在 dependencies，可用于生产环境的打包，webpack的时候缓存这部分依赖 <br> 3. npm shrinkwrap（冻结依赖模块的版本）加 shrinkpack（打包依赖模块到自己项目）来解决依赖模块的不确定性| | |
| yarn | | | |

### 版本控制工具
|   | 用法  | 优点 | 缺点 |
|-----|-------|----------|-----------|
| svn |  | | |
| git | 1. 初始化：git init <br>2. 提交所有修改文件：-A | 指定文件名： git add -A <br> 3. 提交修改说明：git commit -m "js" <br> 4. 指定上传仓库： git remote add origin https://github.com/zhanglizhen0/vue-scaffold.git <br> 5. 上传： git push -u origin master 6. 更新文件：git pull https://github.com/zhanglizhen0/vue-scaffold.git <br>| | |

# JavaScript
### 字符串方法
| 方法 | 说明 |
|----- |------|
| str.indexOf() | 返回关键字所在位置，如果没有找到，返回-1 |
| str.lastIndexOf() | 返回关键字所在位置，如果没有找到，返回-1, 从尾部开始查找|
| String(str) | 字符串类型转换 |
| str.slice(start, end+1) | 将传入的负值与字符串的长度相加 |
| str.substring(start, end+1) | 把所有的负值参数都转换为0，同时这个方法会将小的数作为开始位置，将大的数作为结束位置 |
| str.substr(start, count) | 将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0 |
| str.split() | 模式方法，根据分隔符(默认为逗号)，分割为数组形式|
| str.replace() | 模式方法 |
| str.match() | 模式方法|
| str.search() | 模式方法，同indexOf(), indexOf()不支持模式查找，search()是其模式查找版本 |
| str.toLowerCase() | 转换为小写字母 |
| str.toUpperCase() | 转换为大写字母 |
| str.encodeURIComponent() | URI编码 |
| str.decodeURIComponent() | URI解码 |
| str.concat() | 字符串拼接 |
| str.charAt() | 以单字符字符串的形式返回给定位置的那个字符 |
| str.charCodeAt() | 返回字符编码 |
| str.fromCharCode() | 用于从码点返回对应字符 |
| es6 | |
| str.codePointAt() | 能够正确处理4个字节储存的字符，返回一个字符的码点。定义在`字符串的实例对象`上 |
| str.fromCodePoint() | 能够正确处理4个字节储存的字符，用于从码点返回对应字符 |
| str.includes() | 返回布尔值，表示是否找到了参数字符串 |
| str.startsWith() | 返回布尔值，表示参数字符串是否在原字符串的头部 |
| str.endsWith() | 返回布尔值，表示参数字符串是否在原字符串的尾部 |
| str.repeat() | 字符串重复 |
| str.padStart() | 字符串头部补全 |
| str.padEnd() | 字符串尾部补全 |
| `` | 模板字符串 |

### 数组方法
| 方法 | 说明 |
|----- |------|
| Array() | 生成数组，缺点：因为参数个数的不同，会导致Array()的行为有差异。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。|
| arr.join() | 将数组转为字符串，可使用分隔符(默认为逗号)<br>`不修改原数组` |
| arr.reverse() | 原数组中的元素颠倒顺序，返回逆序数组<br> `修改原数组` |
| arr.sort() | 默认情况下，按升序排列数组项，sort()方法会调用每个数组的toString()，然后比较得到的字符串，即使数组中的每一项都是数值，sort()方法比较也是字符串 |
| arr.concat() | 1. 指定参数时，基于当前数组中的所有项创建一个新数组，具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 <br>2. 参数为空时，可进行数组的浅拷贝<br>`不修改原数组`|
| arr.slice() | 1. 指定参数时, 基于当前数组中的一或多个项创建一个新数组，接收一或两个参数，即开始位置和结束位置 <br>2. 参数为空时，可进行数组的浅拷贝<br>`不修改原数组
| arr.splice() | splice()的前两个参数指定了需要删除的数组元素，后面的任意个参数指定了需要插入到数组中的元素<br> `修改原数组`  |
| arr.push() | 数组尾部插入元素 <br> `修改原数组`|
| arr.pop() | 数组尾部删除元素 <br> `修改原数组` |
| arr.unshift() | 数组头部插入元素 <br> `修改原数组` |
| arr.unshift() | 数组头部删除元素 <br> `修改原数组` |
| arr.forEach() | 对数组中的每一项运行函数。这个方法没有返回值 |
| arr.map() | 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 |
| arr.filter() | 对数组中的每一项运行给函数，返回该函数会返回true的项组成的数组 |
| arr.every() | 对数组中的每一项运行给定函数，如果该函数对每一项都返回true， 则返回true |
| arr.some() | 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true |
| arr.reduce() | （化简函数）迭代数组的所有项，然后构建一个最终返回的值，其中，reduce()方法从数组的第一项开始，逐个遍历到最后。<br> 接收`两个参数`: 一个在每一项上调用的`函数`和(可选的)作为缩小基础的`初始值`。<br>传给reduce()和reduceRight()的函数接收4个参数: 前一个值，当前值，项的索引和数组对象 |
| arr.reduceRight() | 同reduce(), 但是从数组的最后一项开始，向前遍历到第一项 |
| arr.indexOf() | 返回找到的第一个元素的索引，没有返回-1 |
| arr.lastIndexOf() | 同indexOf(), 顺序为尾部开始查找|
| Array.isArray(arr) | 确定某个值是否为数组，不管它是在哪个全局执行环境中创建的 |
| es6 | |
| ...arr | 数组的扩展，<br> 1. 复制数组 <br> 2.合并数组 <br> 3.可把具有iterator接口的类数组对象转为数组 |
| Array.from() | 转为数组，类似数组的对象和可遍历(iterable)的对象 |
| Array.of() | 用于将一组值，转换为数组。<br>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载  |
| 数组实例方法(Array.prototype.xx) | |
| copyWithin | 在当前数组内部，将指定位置的成员复制到其他位置(会覆盖原有成员)，然后返回当前数组 <br>Array.prototype.copyWithin(target, start = 0, end = this.length)|
| arr.find(fn) | 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 |
| arr.findIndex(fn)| 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br>两个方法都可以发现NaN |
| arr.fill() | 使用给定值，填充一个数组 |
| arr.entries() | 返回数组的键值对 [keys,values]|
| arr.keys() | 数组，返回所有键 |
| arr.values() | 数组，返回所有的值 |
| arr.includes() | 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。`ES2016`引入了该方法|
| flat() | 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对`原数据没有影响`。<br>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。<br> 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数 |
| flatMap() | 对原数组的每个成员执行一个函数, 然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，`不改变原数组` |

### 对象方法
| 方法 | 说明 |
|----- |------|
| Object.create() |创建对象，第一个参数是对象原型， 第二个参数是对象的属性描述 |
| in操作符 | 检测属性，`自身`属性，`继承`属性，同时可以区分不存在的属性和存在但值为undefined的属性 <br> property in obj |
| obj.hasOwnProperty(p) | 检测一个属性是在于实例中，还是存在于原型中 |
| obj.propertyIsEnumerable(p) | 检测自有属性且可枚举 |
| for...in | 循环遍历对象`自身`的和`继承`的可枚举属性 |
| Object.keys(obj) | 返回一个数组， 包括对象自身的（不含继承的）所有可枚举属性的键名 |
| Object.values(obj) | `ES2017`引入，返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(不含Symbol属性)属性的键值 |
| Object.entries(obj) | `ES2017`引入，返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(不含Symbol属性)属性的键值对数组 |
| Object.getOwnPropertyNames(obj) | 获得所有实例属性，无论是否可枚举。 |
| Object.getOwnPropertyDescriptor(obj, 'foo') | 获取该属性的描述对象 |
| Object.getOwnPropertyDescriptors(obj) | `ES2017引入`, 获得对象自有属性的属性描述符。<br> 主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题 <br> 配合Object.create方法，将对象属性克隆到一个新对象(`浅拷贝`) |
| Object.defineProperty(obj, key , obj) | 设置属性。`三个参数`: 属性所在的对象、属性的名字和一个描述符对象 |
| Object.defineProperties(obj, obj) | 设置属性。`两个参数`: 第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应 |
| isPrototypeOf() | 确定原型和实例的关系 <br> Person.prototype.isPrototypeOf(person1)|
| Object.is() | `ES6` 对象的比较，<br>Object.is(+0, -0) // false <br>Object.is(NaN, NaN) // true|
| Object.assign() |`ES6` 用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象(target) <br>`Object.assign(target, source1, source2)` <br>`浅拷贝` |
| Object.getOwnPropertySymbols(obj) | 返回一个数组，包含对象自身的所有Symbol属性的键名 |
| Reflect.ownKeys(obj) | `ES6` 返回一个数组，包含对象自身的所有键名，不管键名是Symbol或字符串，也不管是否可枚举 |
| Object.setPrototypeOf() | `ES6` 作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身|
| Object.getPrototypeOf(obj) | `ES6` 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象，返回`[[Prototype]]`的值 |
| ...obj | `ES2018`将扩展运算符引入了对象。<br>扩展运算符可以用于合并两个对象。<br> `let ab = { ...a, ...b }` |

### BOM

### DOM
