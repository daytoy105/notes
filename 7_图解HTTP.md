# 了解Web及网络基础
1. 现在已经提出了3项WWW构建技术，分别是：把SGML(Standard Generalized Markup Language,标准通用标记语言)作为页面的文本标记语言的HTML；作为文档传递协议的HTTP; 指定文档所在地址的URL。
2. TCP/IP
	+ 族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层

	| 层次 | 描述 |
	|-----|----|
	| 应用层 | 决定了向用户提供应用服务时通信的活动。如HTTP |
	| 传输层 | 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据报协议) |
	| 网络层 | 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。 |
	| 链路层 | 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设置驱动、NIC(Network Interface Card,网络适配器，即网卡)，及光纤等物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在链路层的作用范围之内。|
	+ TCP协议三次握手策略
	<br>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
3. 域名解析服务
	<br>DNS(Domain Name System)服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。
4. 绝对URI的格式
	<br> `http://user:pass@www.example.jp:80/dir/inidex.html?uid=1#ch1`
	<br>协议方案名 登录信息(认证)服务器地址 服务器端口号 带层次的文件路径 查询字符串 片段标识符

# 简单的HTTP协议
1. 简介
	+` 请求报文`是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。
	+ `响应报文`基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码原因短语、可选的响应首部字段以及实体主体构成。
	+ HTTP是一种不保存状态，即`无状态协议`。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。
2. HTTP方法
	| 方法 | 描述 |
	|-----|-------|
	| GET | 获取资源。<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容 |
	| POST | 传输实体主体 |
	| PUT | 传输文件。<br>1. PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。<br>2. 但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST(REpresentational State Transfer，表征状态转移)标准的同类Web网站，就可能会开放使用PUT方法。|
	| HEAD | 获得报文首部。<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。
	| DELETE | 用来删除文件。<br>是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。<br>但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。|
	| OPTIONS | 询问支持的方法。<br>用来查询针对请求URI指定的资源支持的方法 |
	| TRACE | 追踪路径。<br>TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。<br>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。<br>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理跳转,TRACE方法就是用来确认连接过程中发生的一系列操作。<br>但是，TRACE方法本来就不怎么常用，加上它容易引发XST(Cross-Site Tracing,跨站追踪)攻击，通常就更不会用到了。
	| CONNECT |要求用遂道协议连接代理<br>CONNECT方法要求在与代理服务器通信时建立遂道，实现用遂道协议进行TCP通信。主要使用SSL(Secure Sockets Layer, 安全套接层)和TLS(Transport Layer Security,传输层安全)协议把通信内容加密后经网络遂道传输。
3. 持久连接
	+ 持久连接(HTTP Persistent Connections,也称为HTTP keep-alive 或 HTTP connection reuse)的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。
	+ 持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web端的显示速度也就相应提高了。
	+ 在HTTP/1.1中，所有的连接`默认都是持久连接`。
4. 并行连接
	+ 通过多条TCP连接发起并行的HTTP请求
	+ 并行连接可能会提高页面的加载速度
	+ 并行连接不一定更快
		+ 客户端的网络带宽不足时，大部分的时间可能都是用来传送数据的，在这种情况下，一个连接到速度较快服务器上的HTTP事务就会很安全容易耗尽所有可能的Modem带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较悭的速度按比例加载，这个带来的性能提升就很小，甚至没什么提升。
		+ 打开大量连接会消耗很多内存资源，从而引发自身的性能问题。
		+ 实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值(通常是4个)。服务器可以随意关闭来自特定客户端的超量连接。
5. 管线化
	+ 持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。
	+ 仅HTTP/1.1支持此技术(HTTP/1.0不支持)，并且只有GET和HEAD要求可以进行管线化，而POST则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议
6. Cookie
	+ Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。
	+ 服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。

___________
# HTTP报文内的HTTP信息
1. 报文与实体
	+ 报文(message)
		<br>是HTTP通信中的基本单位，由8位组字节流(octet sequence, 其中octet为8个比特)组成，通过HTTP通信传输。
	+ 实体(entity)
		<br>作为请求或响应的有效载荷数据(补充项)被传输，其内容由实体首部和实体主体组成。
	+ HTTP报文的主体用于传输请求或响应的实体主体。
	+ 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。
2. 压缩传输的内容编码
	+ HTTP协议中有一种被称为内容编码的功能，内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。
	+ 常见的内容编码有以下几种
		<br>gzip (GNU zip) / compress (UNIX系统的标准压缩) / deflate (zlib) / identity (不进行编码)
3. 分割发送的分块传输编码
	<br>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码(Chunked Transfer Coding)。
4. 发送多种数据的多部分对象集合
	<br>状态码206(Partial Content，部分内容)响应报文包含了多个范围的内容时使用。
5. 获取部分内容的范围请求
	+ 执行范围请求时，会用到首部字段Range来指定资源的byte范围。
	+ 针对范围请求，响应会状态码为`206 Partial Content`的响应报文。另外，对于多重范围的范围请求，响应会在首部字段`Content-Type`标明multipart/byteranges后返回响应报文。如果服务器端无法响应范围请求，则会返回状态200 OK和完整的实体内容。
6. 内容协商返回最合适的内容
	+ 当浏览器的默认语言为英语或中文，访问相同的URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商(Content Negotiation)
	+ 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。
	+ 内容协商技术有以下3种类型
		+ 服务器驱动协商(Server-driven Negotiation)
		+ 客户端驱动协商(Agent-driven Negotiation)
		+ 透明协商(Transparent Negotiation)
____________
# 返回结果的HTTP状态码
1. 状态码的类型

	|			|			类别                       |   原因短语        |
	|-----|--------------------------------|------------------|
	| 1xx  |  Informational(信息性状态码)   |    接收的请求正在处理
	| 2xx  |  Success(成功状态码)           |    请求正常处理完毕
	| 3xx  |  Redirection(重定向状态码)     |    需要进行附加操作以完成请求
	| 4xx  |  Client Error(客户端错误状态码)|    服务器无法处理请求
	| 5xx  |  Server Error(服务器错误状态码)|    服务器处理请求出错

2. 状态码总结

	| 状态码    | 原因短语                     |  含义  |
	|----------|-----------------------------|----------|
	| 100    | Continue             | 说明接收到了请求的初始部分，请客户端继续。发送了这个状态之后，服务器在收到请求之后必须进行响应。|
	| 101    | Switching Protocols  | 说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议 |
	| 200    | OK                   | 表示从客户端发来的请求在服务器端被正常处理了 |
	| 201    | Created              | 用于创建服务器对象的请求(PUT)，响应的实体主体部分中应该包含各种引用了已创建的资源URL，Loaction首部包含的则是最具体的引用 |
	| 204    | No Content           | 表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。|
	| 206    | Partial Content      | 成功执行了一个部分或Range(范围)请求。206响应中必须包含Content-Range、Date以及ETag或Content-Location首部。 |
	| 300    | Multiple Choices     | 客户端请求一个实际指向多个资源的URL时会返回这个状态码。|
	| 301    | Move Permanently     | 在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。 |
	| 302    | Found                | 与301状态码类似，但是，客户端应该使用Location首部给出的URL来临时定位资源，将来的请求仍应用老的URL (HTTP/1.0)
	| 303    | See Other            | 303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别 |
	| 304    | Not Modified         | 该状态码表示 客户端发送附带条件的请求(请求报文中包含if-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since中的任一首部)时，服务器端允许请求访问资源，但满足条件的情况。304状态码返回时，不包含任何响应的主体部分，304虽然被划分在3XX类别中，但和重定向没有关系 |
	| 305    | Use Proxy            | 用来说明必须使用一个代理来访问资源，代理的位置由Location首部给出 |
	| 307    | Temporary Redirect   | 与301状态码类似，但客户端应该使用Location首部给出的URL来临时定位资源(HTTP/1.1)|
	| 400    | Bad Request          | 用于告知客户端它发送了一个错误的请求 |
	| 401    | Unauthorized         | 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证 |
	| 403    | Forbidden            | 用于说明请求被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题(从未授权的发送源IP地址试图访问)等列举的情况都可能是发生403的原因。 |
	| 404    | Not Found            | 用于说明服务器无法找到所请求的URL |
	| 405    | Method Not Allowed   | 发起的请求中带有所请求的URL不支持的方法 |
	| 407    | Proxy Authentication Required  | 与401类似，但用于要求对资源进行认证的代理服务器 |
	| 408    | Request Timeout      | 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接 |
	| 409    | Conflict             | 用于说明请求可能在资源上引发的一些冲突 |
	| 500    | Internal Server Error  | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码 |
	| 501    | Not Implemented      | 客户端发起的请求超出服务器的能力范围 |
	| 502    | Bad Gateway          | 作为代理或网关使用的服务器从请求响应链的下一条链路上接收了一条伪响应时，使用此状态码 |
	| 503    | Service Unavailable  | 用来说明服务器现在无法为请求服务，但将来可以 |
	| 504    | Gateway Timeout      | 与状态码408类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了 |
	| 505    | HTTP Version Not  Supported    | 服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码 |

______
# 与HTTP协作的Web服务器
1. 通信数据转发程序
	1) 代理
		+ 代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。
		+ 使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取日志为主要目的，等等。
		+ 代理有多种使用方法，按两种基准分类，一种是是否使用缓存，另一种是是否修改报文
		+ 缓存代理
			代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。
		+ 透明代理
			转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之，对报文内容进行加工的代理被称为非透明代理。
	2) 网关
		+ 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。
		+ 利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。
	3) 遂道
		+ 遂道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。
		+ 遂道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。遂道的目的是确保客户端能与服务器进行安全的通信。
		+ 遂道本身不会去解析HTTP，也就是说，请求保持原样中转给之后的服务器，遂道会在通信双方断开连接时结束。
2. 保存资源的缓存
	+ 缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因为客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。
	1) 缓存的有效期限
		+ 即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。
	2) 客户端的缓存
		+ 缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。
		+ 另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性，若判断浏览器缓存失效，浏览器会再次请求新资源。
______________
# HTTP首部
1. HTTP报文首部
	1) 请求报文首部
		+ 请求行：方法、URI、HTTP版本
		+ HTTP首部字段：`请求首部字段`、通用首部字段、实体首部字段
		+ 其他
	2) 响应报文首部
		+ 状态行：HTTP版本、状态码
		+ HTTP首部字段：`响应首部字段`、通用首部字段、实体首部字段
		+ 其他
	3) 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。
2. 通用首部字段
	<br>通用首部字段是指，请求报文和响应报文双方都会使用的首部
	| 字段 | 描述 |
	|------|------|
	| Cache-Control | 通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。<br>`no-cache`: 目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。如果服务器的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。<br>`no-store`: 当使用no-store指令时，暗示请求(和对应的响应)或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br>`max-age`:当客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时间。<br>应用HTTP/1.1版本的缓存服务器遇到同时存在`Expires`首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。而HTTP/1.0版本的缓存服务器的情况却相反，max-age指令会被忽略掉。
	| Connection | 具备两个作用：控制不再转发给代理的首部字段；管理持久连接 <br>1. 在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段(即Hop-by-hop首部) <br>2. HTTP/1.1版本的默认连接都是持久连接。为此客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。HTTP/1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为`Keep-Alive`
	| Pragma | Pragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。如：Cache-Control:no-cache Pragma:no-cache。|
	| Via | 使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段Via中附加对该服务器的信息，然后再进行转发。|
3. 请求首部字段
	<br>`请求首部字段`是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优待级等内容。

	| 字段 | 描述 |
	|------|------|
	| Accept | Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。|
	| Accept-Charset | 可用来通知服务器用户代理支持的字符集及字符集相对优待顺序。|
	| Accept-Encoding | 用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序 |
	| Host |首部字段Host会告知服务器，请求的所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。|
	| If-Match | 形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br>只有当`If-Match`的字段值跟`ETag`值匹配一致时，服务器才会接受请求。|
	| If-Modified-Since | If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段`Last-Modified`来确定。<br>If-Modified-Since将上一次服务器传回的Last-Modified的时间戳发送给服务器，服务器会通过这个时间戳验证客户端的资源是否是最新的，如果不是，则返回新的内容。如果是最新的，则返回状态码304 Not Modified的响应，告知客户端从本地缓存中获取资源。 |
	| If-None-Match | 只有当If-None-Match的字段值与ETag值不一致时，可处理该请求。与If-Match首部字段的作用相反。<br>在GET或HEAD方法中使用首部字段If-None-Match可获得最新的资源。因此，这与使用首部字段If-Modified-Since时有些类似。|
	| If-Range | 首部字段If-Range属于附带条件之一。它告知服务器若指定的If-Range字段值(ETag值或者时间)和请求资源的ETag值或时间相一致，则作为范围请求处理。反之，则返回全体资源。|
	| If-Unmodified-Since | 首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。它的作用是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回。|
	| Referer | 首部字段Referer会告知服务器请求的原始资源的URI。<br> 客户端一般会发送Referer首部字段给服务器。但当直接在浏览器的地址栏输入URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的URI中的查询字符串可能含有ID和密码等保密信息，要是写进Referer转发给其他服务器，则有可能导致保密信息的泄露。|
	| User-Agent | 首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达服务器<br>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址，此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。
4. 响应首部字段
	<br>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。

	| 字段 | 描述 |
	|------|------|
	| ETag | 首部字段ETag能告知客户端`实体标识`。它是一种可将资源以字符串形式做唯一标记的方式。服务器会为每份资源分配对应的ETag值。另外，当资源更新时，ETag值也需要更新。生成ETag值时，并没有统一的算法规则，而仅仅是由服务器来分配。<br>强ETag值，不论实体发生多么细微的变化都会改变其值。<br>弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W/。 |
	| Location | 使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源 |
	| Proxy-Authenticate | 首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端。|
	| WWW-Authenticate | 首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案(Basic或是Digest)和带参数提示的质询(challenge)。状态码401 Unauthorized响应中，肯定带有首部字段WWW-Authenticate。|
5. 实体首部
	<br>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

	| 字段 | 描述 |
	|------|------|
	| Allow | 首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。|
	| Content-Length | 首部字段Content-Length表明了实体主体部分的大小(单位是字节)。|
	| Content-Range | 针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。|
	| Expires | 首部字段Expires会将资源失效的日期告知客户端。缓存服务器在接收在含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。<br>源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段Date相同的时间值。<br>但是，当首部字段Cache-Control有指定max-age指令时，比起首部字段Expires,会优先处理max-age指令。 |
	| Last-Modified | 首部字段Last-Modified指明资源最终修改的时间。一般来说，这个值就是Request-URI指定资源被修改的时间。|
6. 为Cookie服务的首部字段
	1) Set-Cookie
		+ 开始状态管理所使用的Cookie信息，响应首部字段
		+ expires属性
			+ Cookie的expires属性指定浏览器可发送Cookie的有效期。
			+ 当省略expires属性时，其有效期仅限于维持浏览器会话(Session)时间段内。这通常限于浏览器应用程序被关闭之前。
			+ 另外，一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作。
		+ path属性
			Cookie的path属性可用于限制指定Cookie的发送范围的文件目录。不过另有方法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。
		+ domain属性
			+ 通过Cookie的domain属性指定的域名可做到与结尾匹配一致。
			+ 除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全。
		+ secure属性
			Cookie的secure属性用于限制Web页面仅在HTTPS安全连接时，才可以发送Cookie。如： Set-Cookie:name=value;secure
		+ `HttpOnly`属性
			Cookie的HttpOnly属性是Cookie的扩展功能，它使JavaScript脚本无法获得Cookie。其主要目的为防止跨站脚本攻击(Cross-site-scripting, XSS)对Cookie的信息窃取。但是，该扩展并非是为了防止XSS而开发的。
	2) Cookie
		<br>首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到Cookie。接收到Cookie时，同样可以以多个Cookie形式发送。
7. 其他首部字段
	1) X-Frame-Options
		+ 首部字段X-Frame-Options属性HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持(clickjacking)攻击。
		+ 两个可指定的字段值： DENY / SAMEORIGIN
	2) X-XSS-Protection
		+ 首部字段X-XSS-Protection属于HTTP响应首部，它是针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关。
		+ 可指定的字段值：0 (将XSS过滤设置成无效状态)、1 (将XSS过滤设置成有效状态)
	3) DNT
		+ 首部字段DNT属性HTTP请求首部，其中DNT是Do Not Track的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。
		+ 可指定的字段值：0(同意被追踪)1(拒绝被追踪)
		+ 由于首部字段DNT的功能具备有效性，所以Web服务器需要对DNT做对应的支持。
	4) P3P
		<br>首部字段P3P属于HTTP响应首部，通过利用P3P(The Platform for Privacy Preferences, 在线隐私偏好平台)技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。
________
# 确保Web安全的HTTPS
1. HTTP的缺点
	1) 通信使用明文(不加密)，内容可能会被窃听
		+ TCP/IP是可能被窃听的网络
		+ 通信的加密
			+ HTTP协议中没有加密机制，但可以通过和`SSL`(Secure Socket Layer，安全套接层)或TLS(Transport Layer Security,安全层传输协议)的组合使用，加密HTTP的通信内容。
			+ 用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS(HTTP Secure,超文本传输安全协议)或HTTP over SSL。
		+ 内容的加密
			+ 由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。
			+ 在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。
	2) 不验证通信方的身份，因此有可能遭遇伪装
		+ HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患：
			+ 无法确定请求发送至目标的Web服务器是否按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。
			+ 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
			+ 无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。
			+ 无法判定请求是来自何方、出自谁手。
			+ 即使是无意义的请求也会照单全收。无法附上海量请求下的DoS(Denial of Service，拒绝服务攻击)
		+ 查明对手的证书
			+ 虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。
			+ 通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。
	3) 无法证明报文的完整性，所以有可能已篡改
2. `HTTP+加密+认证+完整性保护=HTTPS`
	+ 在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。
	+ SSL是独立于HTTP的协议，所以不光是HTTP，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术
	1) 共享密钥加密
		+ 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system),也被叫做对称密钥加密。
	2) 使用两把密钥的公开密钥加密
		+ 公开密钥加密使用一对非对称的密钥，一把叫做私有密钥(private key)，另一个把叫做公开密钥(public key).
		+ 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。
	3) HTTPS采用混合加密机制
		+ 公开密钥加密与共享密钥相比，其处理速度要慢
		+ 在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。
	4) 证明公开密钥正确性的证书
		<br>使用由数字证书认证机构(CA, Certificate Authority)和其相关机关颁发的公开密钥证书
3. 为什么不一直使用HTTPS
	+ 与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。
	+ 节约购买证书的开销。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构(CA)购买。证书价格可能会根据不同的认证机构略有不同。
_________
# 确认访问用户身份的认证
1. BASIC认证
	+ BASIC认证(基本认证)是从HTTP/1.0就定义的认证方式。即使是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行认证方式。
	+ BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。
	+ 另外，除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。
	+ BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。
2. DIGEST认证
	+ DIGEST认证同样使用质询/响应的方式(challenge/response)，但不会像BASIC认证那样直接发送明文密码。
	+ 所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式
3. SSL客户端认证
	+ SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。
	+ 认证步骤
		1) 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。
		2) 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器。
		3) 服务器验证客户端证书，验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。
________
# 基于HTTP的功能追加协议
1. 消除HTTP瓶颈的SPDY
	1) 使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。若想在现有Web实现所需的功能，以下这些HTTP标准就会成为瓶颈。
		+ 一条连接上只可发送一个请求。
		+ 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
		+ 请求/响应首部未经压缩就发送。首部信息越多延迟越大。
		+ 发送冗长的首部。每次互相发送相同的首部造成浪费较多。
		+ 可任意执行数据压缩格式。非强制压缩发送。
	2) Ajax的解决方法
		+ Ajax的核心技术是通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。借由这种手段，就能从已加载完毕的Web面面上发起请求，只更新局部页面。
		+ 而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生，另外，Ajax仍未解决HTTP协议本身存在的问题。
	3) Comet的解决方法
		+ 一旦服务器端有内容更新了，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送(Server Push)的功能。
		+ 通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。
		+ 内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决HTTP协议本身存在的问题。
	4) SPDY的设计与功能
		<br>使用SPDY后，HTTP协议额外获得以下功能。
		+ 多路复用流
			<br>通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。
		+ 赋予请求优先级
			<br>SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
		+ 压缩HTTP首部
			<br>压缩HTTP请求和响应的首部，这样一来，通信产生的数据包数量和发送的字节数就更少了。
		+ 推送功能
			<br>支持服务器主动向客户端推送数据的功能。这样，服务器可发送数据，而不必等待客户端的请求。
		+ 服务器提示功能
			<br>服务器可以主动提示客户端请求所需的资源。由于客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。
2. WebSocket
	+ WebSocket，即Web浏览器与Web服务器之间`全双工通信`标准。
	1) WebSocket协议的主要特点
		+ 推送功用
			<br>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等客户端的请求。
		+ 减少通信量
			<br>只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。
_________
# Web的攻击技术
+ 简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击目标。
1. 针对Web应用的攻击模式
	1) 以服务器为目标的主动攻击
		+ 主动攻击(active attack)是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。
		+ 主动攻击模式里具有代表性的攻击是SQL注入和OS命令注入攻击。
	2) 以服务器为目标的被动攻击
		+ 被动攻击(passive attack)是指复用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者都不直接对目标Web应用访问发起攻击。
		+ 被动攻击模式中具体代表性的攻击是`跨站脚本攻击`和`跨站请求伪造`
2. 因输出值转义不完全引发的安全漏洞
	1) 实施Web应用的安全对策大致分为以下两部分
		+ 客户端验证
			<br>多数情况下JavaScript在客户端验证数据。可是在客户端允许篡改数据或关闭JavaScript,不适合将JavaScript验证作为安全的防范对策。保留客户端验证只是为了更早地辨识输入错误，起到提高UI体验的作用。
		+ Web应用端(服务器端)的验证
			+ 输入值验证
			+ 输出值转义
	2) 跨站脚本攻击
		+ 跨站脚本攻击(Cross-Site Scripting,XSS)是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞，就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。
		+ 跨站脚本攻击有可能造成以下影响
			+ 利用虚假输入表单骗取用户个人信息
			+ 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
			+ 显示伪造的文章或图片
	3) SQL注入攻击
		+ SQL注入攻击(SQL Injection)是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击，该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露
		+ SQL注入攻击有可能会造成以下等影响
			+ 非法查看或篡改数据库内的数据
			+ 规避认证
			+ 执行和数据库服务器业务关联的程序等
	4) OS命令注入攻击
		+ OS命令注入攻击(OS Command Injection)是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。
	5) HTTP首部注入攻击
		+ HTTP首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。
		+ 向首部主体内添加内容的攻击称为HTTP响应截断攻击(HTTP Response Splitting Attack)
		+ HTTP首部注入攻击有可能会造成以下一些影响
			+ 设置任何Cookie信息
			+ 重定向至任意URL
			+ 显示任意的主体(HTTP响应截断攻击)
				<br>%0D%0A  换行符，可插入产的首部字段
				<br>%0D%0A%0D%0A 两个连续换行就可作出HTTP首部与主体分隔所需的空行，这样就能显示伪造的主体，达到攻击的目的。
	6) 邮件首部注入攻击
		+ 邮件首部注入(Mail Header Injection)是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件。
		+ (参考HTTP首部注入方式)
	7) 目录遍历攻击
		+ 目录遍历(Directory Traversal)攻击是指对无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历(Path Traversal)攻击。
		+ 应该关闭指定对任意文件名的访问权限
