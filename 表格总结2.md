## webpack4.x
### loaders
| 功能         | loader                       |
| ------------ | ---------------------------- |
| 加载css      | style-loader、css-loader     |
| 加载sass     | node-sass、sass-loader       |
| css 自动补全 | postcss-loader(在css-loader之后，预编译之前)、autoprefixer(指定版本)<br>使用：1. 模块导出  2. options配置<br> plugins: [require("autoprefixer")({ browsers: ['last 2 versions'] })]|

### plugins
| 功能 | plguins |
| ---- | ----------------------- |
| CDN引入外部文件 | html文件引入需加载的文件，webpack配置externals |
| 提取模板文件 | new webpack.optimize.SplitChunksPlugin() |
| 提取css文件 | 1. mini-css-extract-plugin (需注意css背景图片路径) <br>rules配置: [{loader: MiniCssExtractPlugin.loader,options: {publicPath: './' }},{loader: "css-loader"}, {loader: "postcss-loader",},{loader: "sass-loader"}]<br>优点：异步；使用预加载或内联css；能根据入口名提取(用于动态路由)<br> 2. extract-text-webpack-plugin@next <br>rules配置: ExtractTextPlugin.extract({fallback: "style-loader", use: ['css-loader',"postcss-loader", 'sass-loader']}) |
| 生产环境压缩 | 默认开启压缩，需指定webpack运行环境，mode |
|  tree shaking | 移除JavaScript上下文中的未引用代码(dead-code)<br> 需要在package.json中配置`sideEffect`, 如果所有代码都不包含副作用，可属性标记为`false`; 有副作用的文件需单独列出，如css, "sideEffect":["*.css"]
| 生成模板文件 | html-webpack-plugin <br> 使用：new HtmlWebpackPlugin()<br>多入口页面时，需要多次调用, chunks指定引入html的入口配置 |
| 清除`/dist`文件夹 | clean-webpack-plugin <br> 使用：new CleanWebpackPlugin(['dist'])<br>容易造成文件夹访问权限问题(冲突？)  |
| 热替换 | 1. webpack-dev-server <br> 2. webpack-dev-middleware + webpack-hot-middleware + express <br> **重点**`publicPath`的配置 |
| 自动打开浏览器 | open-browser-webpack-plugin <br>new OpenBrowserPlugin({url: 'http://localhost:80/dist/#/'}) |
| 模块标识符 | 1. NamedModulesPlugin <br>`[hash]` 当开启HMR的时候使用该插件会显示模块的`相对路径`，建议用于开发环境。<br> new webpack.NamedModulesPlugin() 2. HashedModuleIdsPlugin <br>`[chunkhash]`推荐用于生产环境构建 <br>使用：new webpack.HashedModuleIdsPlugin() |
___________
## Vue 技术栈 vs **React 技术栈**
### Vue
| 功能   |  vue  |  react  |
|-----|-------|-----|
| 原理 |1.在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。<br> | virtual dom diff reconcilation fiber |
| 生命周期 | beforeCreate() created() <br> beforeMount() mount() <br> beforeUpdate() update() <br> beforeDestroy() destroyed()| 1. `mounting`: constructor() -> getDerivedStateFromProps(props, state ) -> render() -> componentDidMount() <br> 2. `updating`: getDerivedStateFromProps(props, state) -> shouldComponentUpdate(nextProps, nextState) -> render() ->  getSnapshotBeforeUpdate(prevPorps, prevState) -> componentDidUpdate(prevProps, prevState, snapshot) <br> 3. `unmounting`: componentWillUnmount() <br> 4. `error`: componentDidCatch(error, info) |
| 创建实例 | new Vue({el:'#app'}) <br> new Vue({router}).$mount('#app') | ReactDOM.render(element, document.getElementById('app'))  |
| 模板语法 | `html` | `JSX` |
| 插入html | \<span v-html="rawHtml">\</span>  | \<span dangerourslySetInnerHTML={{__html:rawHtml}}>\</span>
| 数据绑定 | 1. `{{data}}` <br> 2. computed: 计算属性是基于它们的依赖进行缓存的 <br> 3. methods：方法是不缓存的，响应变化，每次调用<br> 4.watch:当需要在数据变化时执行异步或开销较大的操作时，响应数据的变化　| `{data}` |
| 条件渲染 | 1. v-if / v-else <br> \<span v-if="ok">Yes\</span>  <br> 2. v-show: 相当于display的切换 <br>v-if有更高的切换开销，而v-show有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好 | js 条件语句 <br>　{ ok ? \<span>\</span> : null } <br> 2.css的display|
| 列表渲染 | v-for, `item`、`index`、`key` <br>属性动态绑定：v-bind, `:` <br> 可配合v-if使用 | map() , 添加 key |
| 事件 | 1. 事件绑定：v-on，`@` <br> 使用：\<span @click="handleClick($event)" >\</span>, <br>获得对象： `$event` <br> 方法不能写成箭头函数形式(this为undefined), 普通方法this指向vue实例  <br> 2.事件修饰符 stop、prevent、capture、self、once、passive <br> 3. 原理：所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的ViewModel上，当一个ViewModel被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。| \<span onClick={this.handleClick.bind(this)}>\</span> <br> 需手动绑定this <br> 2. 阻止事件默认行为，evnet.preventDefault() |
| 表单 | 1. `v-model`: 双向绑定 (value/input结合), 根据控件类型自动选取正确的方法来更新元素<br>忽略所有表单元素的 value、checked、selected特性的初始值而总是将Vue实例的数据作为数据来源 | 受控组件, `value` / `checked` , `onChange()` <br> 2. 非受控组件, `ref`、`defaultValue`|
| 组件 |
| 创建 | Vue.component('blog',{template:'<p>{{value}}</p>'}) <br> | es6 class / function() |
| 向子组件传递数据 | props：1. props单向下行绑定 <br> 2. 使用字符串`静态`传递时，在JS中是camelCase，在Html中是kebab-case <br>3. 动态传递v-bind, 为js表达式,可以是数字、变量、对象等,<br> v-bind="obj"// 传递obj的所有属性 <br> 4. props验证，属性有type、required、default、validator<br> 父：\<blog post-value='Vue'  <br>子：props,:['postValue'] /> | props : 1. 自顶而下，单向流动<br> 2. 传递的类型可以是任何类型, 形式为 name={obj}, 或 {...obj} <br>3. props验证, props-type (import) <br> 父: \<component title="name" /> <br>子：this.props.title |
| 事件向父级组件发送消息| 子：$emit('事件名', params)  <br> 父：组件用`v-on`监听的事件名, $event: 指向参数 <br> 子：template:'<p @click="$emit('pclick','333')">\</p>'  <br> 父：\<blog @pclick="child=$event"> | 回调函数、props <br> 父: \<component save = {(value)=>this.handleSave(value)} > <br> 子: this.props.save('haha') |
| 向组件传递内容|  `<slot>`, 还可以在节点或模板中定义slot属性，指定位置插入内容 | this.props.children |
| 动态组件| 动态属性 `is`，若需缓存组件内容，`<keep-alive>` | 配合生命周期使用, 缓存，sessionStorage等 |
| 组件的使用 | 1. 全局注册，需要在vue实例创建之前发生<br> 2. 局部注册，components属性中指定使用的组件名 | 1. 组件直接嵌套<br>2. 高阶组件 @Hoccomponet <br>3. React.createElement() <br> 4. React.createPortal() |
| 传递原生事件 |1. 事件修饰符`native`，缺点：传递在直接根节点下，若根节点没有这个原生事件，则不会被触发。<br> 2. Vue的`$listeners`属性, 可以指定在需要的节点上，合并所有的事件：Object.assgin或对象扩展 |  |
| v-model | 1. 组件中使用v-model，单选、复选等类型需要额外声明避免冲突,`model`属性解决 <br> model:{prop:'checked',event:'change'} <br>子：value需在props中指定，template中需要显式定义value，input <br> 父：\<blog v-model=""/> <br> 4. 修改符`sync` , props的单向绑定 | `props`和`回调函数`结合使用 |
| 访问元素 | 1. 访问根实例`$root` <br> 2. 访问父组件 `$parent` <br> 3. 访问子组件实例, 组件定义ref属性，字符串形式，调用：`this.$ref.xxx`<br> 4. 依赖注入：嵌套组件(多)的情况,使用` provide`、`inject` | 1. 访问组件实例 <br>this.myRef = React.createRef() <br> 回调函数 <br> React 17 取消字符串形式<br> 2. 向子组件传递ref: forwardRef() <br> 3.嵌套组件(多)的传递, `context` <br> const TContext = React.createContext(), `<TContext.Provider>`、`<TContext.Comsumer>` |
| class样式 | 外部文件引入<br> 模板内部 \<lang scoped > , `scoped` 局部 <br> \<a class = '{ active: isActive }' /> ，多个动态class，数组形式 | 外部文件引入 <br> \<a className={`${isActive?'active':''}`} /> ，自由扩展 |
| 过渡、动画 |`<transition name="fade">` <br> 1. 过渡的类名(`v`为name的值): v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to <br>| |
### Vue-Router

### Vuex

### antd-design

### high-charts



_________

### http请求
|     | 用法 |优点   |  缺点 |
|--------|---------|----|----|
| fetch |`whatwg-fetch`<br> let res = await fetch(url) // res是未处理对象集合，若需要json格式，需要执行`res.json()`| 1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里<br> 2. 更加底层，提供的API丰富（request, response）<br>3.支持JSONP，引入`fetch-jsonp` | 1. fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 <br> 2. fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行<br> 3. fetch没有办法原生监测请求的进度，而XHR可以 |
| axios | let res = await axios(url) //res是响应结果}) | 1.从node.js创建http请求 <br>2.支持Promise API <br>3.转换请求和响应数据<br> 4. 取消请求 <br>5. 自动转换JSON数据<br> 6.客户端支持防止CSRF/XSRF | 不支持JSONP |
| jq ajax | $.get(url) | 基于原生的XHR开发 | JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理  |


### css预处理器
|   | 用法  | 优点 | 缺点 |
|-----|-------|----------|-----------|
| Sass |  | | |
| Less | | | |


### 包管理器
|   | 用法  | 优点 | 缺点 |
|-----|-------|----------|-----------|
| npm |  | | |
| yarn | | | |

### 版本控制工具
|   | 用法  | 优点 | 缺点 |
|-----|-------|----------|-----------|
| svn |  | | |
| git | | | |
