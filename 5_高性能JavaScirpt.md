# 加载和执行
1. 脚本位置
	+ 由于脚本会阻塞页面其他的资源的下载，因此推荐将所有的`<script>`标签尽可能放到`<body>`标签的底部，以尽量减少对整个页面下载的影响。
2. 组织脚本
	+ 由于每个`<script>`标签初始下载时都会阻塞页面渲染，所以减少页面包含的`<script>`标签数量有助于改善这一情况。这不仅仅是针对外链脚本，内嵌脚本的数量同样也要限制。浏览器在解析HTML页面的过程中每遇到一个`<script>`标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。
	+ 这个问题在处理外链JavaScript文件时略有不同。考虑到HTTP请求会带来额外的性能开销。减少页面中的外链脚本文件的数量将会改善性能
3. 无阻塞的脚本
	1) 延迟的脚本
		带有defer属性的`<script>`标签可以放置在文档的任何位置，对应的JavaScript文件将在页面解析到`<script>`标签时开始下载，但不会执行，直接DOM加载完成(onload事件被触发前)。不会阻塞浏览器的其他进程。
	2) async与defer
		相同点是采用并行下载，在下载过程中不会产生阻塞。区别在于执行时机，async是加载完成后自动执行，而defer需要等待页面完成后执行
	3) 动态脚本元素
		+ 无论在何时启动下载，文件的下载和执行过程不会阻塞页面其他进程
		+ 动态加载可保证执行顺序
		```javascript
		function loadScript(url, callback) {
		  var script = document.createElement('script')
		  if (script.readyState) { // IE
		    script.onreadystatechange = function() {
		      if (script.readyState == "loaded" || script.readyState == "complete") {
		        script.onreadystatechange = null
		        callback()
		      }
		    };
		  } else {
		    script.onload = function() {
		      callback()
		    };
		  }
		  script.src = url
		  document.getElementsByTagName('head')[0].appendChild(script)
		}
		```
	4) XMLHttpRequest脚本注入
		+ 另一种无阻塞加载脚本的方法是使用XMLHttpRequest(XHR)对象获取脚本并注入页面中。
		+ 这种方法主要优点是，可以下载JavaScript代码但是不立即执行。由于代码是在`<script>`标签之外返回的，因此它下载后不会自动执行，这使得你可以把脚本的执行推迟到你准备好的时候，另一个优点是，同样的代码在所有主流浏览器中都能正常工作。
		+ 主要局限性是JavaScript文件必须与所请求的页面处于相同的域，这意味着JavaScript文件不能从CDN下载。因此，大型的web应用通常不会采用XHR脚本注入技术
______
# 数据存取
1. 管理作用域
	1) 作用域链和标识符解析
		+ 每个JavaScript函数都表示为一个对象，更确切地说，是Function对象的一个实例。
		+内部属性[[Scope]]包含了一个函数被创建的作用域中对象的集合。这个集合被称为函数的作用域链。它决定哪些数据能被函数访问。函数作用域中的每个对象被称为一个可变对象，每个可变对象都以"键值对"的形式存在。
		+ 函数执行时会创建一个称为执行环境(execution context)的内部对象。每个执行环境都有自己的作用域链，用于解析标识符。当执行环境被创建时，它的作用域链初始化为当前运行函数的[[Scope]]属性中的对象。这些值按照它们出现在函数中的顺序，被复制到执行环境的作用域链中。这个过程一旦完成，一个被称为“活动对象(activation object)”的新对象就为执行环境创建好了。活动对象作为函数运行时的变量对象，包含了所有局部变量、命名参数、参数集合以及this。然后此对象被推入作用域链的最前端。当执行环境被销毁，活动对象也随之销毁。
		+ 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或存储数据。该过程搜索执行环境的作用域链，查找同名的标识符。搜索过程从作用域链头部开始，也就是当前运行函数的活动对象。如果找到，就使用这个标示符对应的变量；如果没找到，继续搜索作用域链中的下一个对象。搜索过程会持续进行，直到找到标识符，若无法搜索到匹配的对象，那么标识符将被视为是未定义的。正是这个搜索过程影响了性能。
	2) 标识符解析的性能
		+ 标识符解析是有代价的，在执行环境的作用域链中，一个标识符所在的位置越深，它的读写速度也就越慢。因此，函数中读写局部变量总是最快的，而读写全局变量通常是最慢的。
		+ 采用过优化的JavaScript引擎的浏览器，比如Chrome 和 Safari 4，访问跨作用域的标识符时就没有类似的性能损失。
	3) 改变作用域链
		+ with语句
		+ try-catch语句
	4) 动态作用域
		+ 无论是with语句还是try-catch语句的catch子句，或是包含eval()的函数，都被认为是动态作用域。动态作用域只存在于代码执行过程中，因此无法通过静态分析
	5) 闭包、作用域和内存
		+ 闭包是JavaScript最强大的特性之一，它允许函数访问局部作用域之外的函数。
		+ 由于闭包的[[Scope]]属性包含了与执行环境作用域链相同的对象的引用，因此会产生副作用。通常来说，函数的活动对象会随着执行环境一同销毁。但引入闭包时，由于引用仍然存在于闭包的[[Scope]]属性中，因此激活对象无法被销毁。这意味着脚本中的闭包与非闭包函数相比，需要更多的内存开销。
		+ 当闭包代码执行时，会创建一个执行环境，它的作用域链与属性[[Scope]]中所引用的两个相同的作用域链对象一起被初始化，然后一个活动对象为闭包自身所创建
		+ 使用闭包最需要关注的性能点：在频繁访问跨作用域的标识符时，每次访问都会带来性能损失。
2. 对象成员
	1) 原型、原型链
		+ 对象在原型链中存在的位置越深，找到它也就越慢。
		+ 搜索实例成员比从字面量或局部变量中读取数据代价更高，再加上遍历原型链带来的开销，这让性能问题更为严重
	2) 嵌套成员
		+ 对象成员嵌套越深，读取速度就会越慢
	3) 缓存对象成员值
		+ 通常来说，在函数中如果要多次读取同一个对象属性，最佳做法是将属性值保存到局部变量中。局部变量能用来替代属性以避免多次查找带来的性能开销。特别是在处理嵌套对象成员时，这样做会明显提升执行速度
_________
# DOM编程
### DOM访问与修改
+ 以下方法的返回值是一个集合：
	+ document.getElementsByName()
	+ document.getElementsByClassName()
	+ document.getElementsByTagName()
	+ document.images
	+ document.links
	+ document.forms
	+ document.forms[0].elements
<br>&ensp;&ensp;&ensp;&ensp;HTML集合以一种"假定实时状(assumed to be live)"实时存在，这意味着当底层文档对象更新时，它也会自动更新。事实上，HTML集合一直与文档保持连接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数(即访问集合的length属性)也是如此，这正是低效之源。
<br>&ensp;&ensp;&ensp;&ensp;一般来说，对于任何类型的DOM访问，需要多次访问同一个DOM属性或方法需要多次访问时，最好使用一个局部变量缓存此成员。当遍历一个集合时，第一优化原则是把集合存在在局部变量中，并把length缓存在循环外部，然后，使用局部变量替代这些需要多次读取的元素。
### 重绘与重排
1. 简介
	+ 浏览器下载页面中的所有组件——HTML标记、JavaScript、CSS、图片——之后会解析并生成两个内部数据结构：
		+ DOM树：表示页面结构
		+ 渲染树：表示DOM节点如何显示
	+ DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点(隐藏的DOM元素在渲染树中没有对应的节点)。渲染树中的节点被称为"帧(frames)"或"盒(boxes)"，符合CSS模型的定义。一旦DOM和渲染树构建完成，浏览器就开始显示(绘制"paint")页面元素
	+ 当DOM的变化影响了元素的几何属性(宽和高)—— 比如改变边框宽度，浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为"重排(reflow)"。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为"重绘(repaint)"。
	+ 并不是所有的DOM变化都会影响几何属性。例如：改变一个元素的背景色并不会影响它的宽和高。在这种情况下，只会发生一次重绘(不需要重排)，因为元素的布局没有改变。
	+ 重绘和重排操作都是代价昂贵的操作，它们会导致Web应用程序的UI反应迟钝。所以，应该尽可能减少这类过程的发生。
2. 重排何时发生
	+ 当页面布局和几何属性改变时就需要"重排"。下列情况中会发生重排。
		1) 添加或删除可见的DOM元素
		2) 元素位置改变
		3) 元素尺寸改变(包括：外边距、内边距、边框厚度、宽度、高度等属性改变)
		4) 内容改变
		5) 页面渲染器初始化
		6) 浏览器窗口尺寸改变
	+ 根据改变的范围和程度，渲染树中或大或小的对应的部分也需要重新计算。有些改变会触发整个页面的重排：例如，当滚动条出现时
3. 渲染树变化的排队与刷新
	+ 由于每次重排都会产生计算消耗，大多数浏览器通过队列变化修改并批量执行来优化重排过程。然而，你可能会强制刷新队列并要求计划任务立刻执行。获取布局信息的操作会导致列队刷新，比如以下方法
		1) offsetTop, offsetLeft, offsetWidth, offsetHeight
		2) scrollTop, scrollLeft, scrollWidth, scrollHeight
		3) clientTop, clientLeft, clientWidth, clientHeight
		4) getComputedStyle() (currentStyle in IE)
	+ 以上属性和方法需要重新返回最新的布局信息，因此浏览器不得不执行渲染队列中的"待处理变化"并触发重排以返回正确的值。
	+ 在修改样式的过程中，最好避免使用上面列出的属性。它们会刷新渲染队列，即使是在获取最近未发生改变的或者与最新改变无关的布局信息。
4. 最小化重绘和重排
	+ 为了减少发生次数，应该合并多次对DOM和样式的修改，然后一次处理掉
	+ 另一个一次性修改样式的办法是修改CSS的class名称，而不是修改内联样式。这种方法适用于那些不依赖于运行逻辑和计算的情况。
5. 批量修改DOM
	+ 当你需要对DOM元素进行一系列操作时，可以通过以下步骤来减少重绘和重排的次数：
		1) 使元素脱离文档流
		2) 对其应用多重改变
		3) 把元素带回文档中
	+ 该过程里会触发再次重排——第一步和第三步。如果你忽略这两个步骤，那么在第二步所产生的任何修改都会触发一次重排
	+ 有三种基本方法可以使DOM脱离文档
		1) 隐藏元素，应用修改，重新显示
		2) 使用文档片断(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档
		3) 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。
	+ 推荐尽可能地使用文档片断，因为它们所产生的DOM遍历和重排次数最少
6. 缓存布局信息
	<br>浏览器尝试通过队列化修改和批量执行的方式最小化重排次数。当你查询布局信息时，比如获取偏移量(offsets)、滚动位置(scroll values)或计算出的样式值(computedstyle values)时，浏览器为了返回最新值，会刷新队列并应用所有变更。最好的做法是尽量减少布局信息的获取次数，在获取后把它赋值给局部变量，然后再操作局部变量。
7. 让元素脱离动画流
	+ 一般来说，重排只影响渲染树中的一小部分，但也可能影响很大的部分，甚至整个渲染树。浏览器所需要重排的次数越少，应用程序的响应速度就越快。因此当页面顶部的一个动画推移页面整个余下的部分时，会导致一次代价昂贵的大规模重排，让用户感到页面一顿一顿的。渲染树中需要重新计算的节点越多，情况就会越糟
	+ 使用以下步骤可以避免页面中的大部分重排
		1) 使用绝对位置定位页面上的动画元素，将其脱离文档流
		2) 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容
		3) 当动画结束时恢复定位，从而只会下移一次文档的其他元素
8. :hover
	<br>如果你有大量元素使用了:hover，那么会降低响应速度。如果你创建一个5列和500~1000行的表格，并使用tr:hover改变背景色来高亮显示鼠标所在的当前行，当鼠标在表格上移动时，性能会降低。高度过程会变慢，CPU使用率会提高到80%~90%。所以在很多时应避免使用这种效果。
### 事件委托
+ 当页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器时，这种情况可能会影响性能。每绑定一个事件处理器都是有代价的，它要么是加重了页面负担(更多的标签或JavaScript代码)，要么是增加了运行期的执行时间。
+ 需要访问和修改DOM元素越多，应用程序也就越慢，特别是事件绑定通常发生在onload（或DOMContentReady）时，此时对每一个富交互应用的网页来说都是一个拥堵的时刻。
+ 事件绑定占用了处理时间，而且浏览器需要跟踪每个事件处理器，这也会占用更多 的内存。这些工作结束时，这些事件处理器中的绝大部分都不再需要（因为并不是100%的按钮或链接会被用户点击），因此有很多工作是没必要的。
+ 一个简单而优雅的处理DOM事件的技术是事件委托。它是基于这样一个事实：事件逐层冒泡并能并父级元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。
+ 根据DOM标准，每个事件都要经历三个阶段： 捕获、到达目标、冒泡。IE不支持捕获，但对于委托而言，冒泡已经足够。
_______
# 算法和流程控制
### 循环
1. 循环类型
	+ for
	+ while
	+ do-while
	+ for-in
	<br>该循环有个非常特别的用途：它可以枚举任何对象的属性(包括对象实例属性以及从原型链中继承而来的属性)
2. 循环性能
	+ 不断引发循环性能争论的源头是循环类型的选择。在JavaScript提供的四种循环类型中，只有for-in循环比其他几种明显要慢；由于每次迭代操作会同时搜索实例或原型属性，for-in循环的每次迭代都会产生更多的开销。因此，除非你明确需要迭代一个属性数量未知的对象，否则应避免使用for-in循环。
	+ 如果循环类型与性能无关，那么该如何选择？
		1) 每次迭代处理的事务
		2) 迭代的次数
	+ 减少迭代的工作量
		1) 在循环前对数组长度进行一次属性查找，并使用局部变量缓存下来
		2) 可以通过颠倒数组的顺序来提高循环性能
	+ 减少迭代次数
3) 基于函数的迭代: forEach()
	<br>尽管基于函数的迭代提供了一个更为便利的迭代方法，但它仍然比基于循环的迭代要慢一些。对每个数组项调用外部方法所带来的开销是速度慢的主要原因。在所有情况下，基于循环的迭代比基于函数的迭代快8倍，因此在运行速度要求严格时，基于函数的迭代不是合适的选择
### 条件语句
1. if-else 对比 switch
	<br>事实证明，大多数情况下switch比if-else运行得要快，但只有当条件数量很大时才快得明显。这个两个语句主要性能区别是：当条件增加时，if-else性能负担增加的程序比switch要多。因此，我们自然倾向于在条件数量较少时使用if-else，而在条件数量较大时使用switch。
2. 优化if-else
	1) 优化if-else的目标是：最小化到达正确分支所需判断的条件数量。最简单的优化方法是确保最可能出现的条件放在首位。if-else的条件语句应该总是按照从最大概率到最小概率的顺序排序，以确保运行速度最快。
	2) 另一种减少条件判断次数的方法是把if-else组织成一系列嵌套的if-else语句。使用单个庞大的if-else通常会导致运行缓慢，因为每个条件都需要判断。采用二分法把值域分成一系列的的区间，然后逐步缩小范围，非常适用于有多个值域需要测试的时候(如果是离散值，那么switch语句通常更为合适)
3. 查找表
	+ 有时候优化条件语句的最佳方案是避免使用if-else和switch。当有大量离散值需要测试时，if-else和switch比使用查找表慢很多。JavaScript中可以使用数组和普通对象来构建查找表，通过查找表访问数据比用if-else或switch快很多，特别是在条件语句数量很大的时候。
	+ 当你使用查找表时，必须完全抛弃条件判断语句。这个过程变成数组项查询或者对象成员查询。查找表的一个主要优点是: 不用书写任何条件判断语句，即便候选值数量增加时，也几乎不会产生额外的性能开销。
	+ 当单个键和单个值之间存在逻辑映射时，查找表的优势就能体现出来。switch语句更适合于每个健都需要对应一个独特的动作或一系列动作的场合
	```javascript
	switch (value) {
	  case: 0
	  return res0;
	  break;
	  ...
	  case9
	  return res9;
	  break;
	  default
	  return res10;
	}
	//
	var results = [res0, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10]
	return resules[value]
	```
### 递归
<br>&ensp;&ensp;&ensp;&ensp;使用递归可以把复杂的算法变量简单。递归函数的潜在问题是终止条件不明确或缺少终止条件会导致函数长时间运行，并使得用户界面处于假死状态。而且，递归函数还可能遇到浏览器的“调用栈大小限制(Call stack size limites)”
1. 调用栈限制
	<br>JavaScript引擎支持的递归数量与JavaScript调用栈大小直接相关。只有IE例外，它的调用栈与系统空闲内存有关，而其他所有浏览器都有固定数量的调用栈限制
2. 递归模式
	1) 直接递归模式,一般写法如下：
		```javascript
		function recurse(){
		  recurse()
		}
		recurse();
		```
	2) 隐伏模式，它包含两个函数
		```javascript
		function first(){
		  second()
		}
		function second(){
		  first()
		}
		first()
		```
	 + 在这种递归中，两个函数相互调用，形成一个无限循环。这种模式更令人不安，在大型代码库中很难定位原因
	 + 大多数调用栈错误都与这两种模式有关。最常见的导致栈溢出的原因是不正确的终止条件，因此定位模式错误的第一步是验证终止条件。如果终止条件没问题，那么可能是算法中包含了太多层递归，为了能在浏览器中安全地工作，建议改用迭代、Memoization，或者结合两者使用。
### 迭代
1. 任何递归能实现的算法同样可以用迭代来实现。迭代算法通常包含几个不同的循环，分别对应计算过程的不同方面，这也会引入它们自身的性能问题。然后，使用优化后的循环替代长时间运行递归模式可以提升性能，因为运行一个循环比反复调用一个函数的开销要少得多。
2. 例如，合并排序算法是最常见的用递归实现的算法。
	```javascript
	function merge(left, right) {
	  var result = []
	  while (left.length > 0 && right.length > 0) {
	    if (left[0] < right[0]) {
	      result.push(left.shift())
	    } else {
	      result.push(right.shift())
	    }
	  }
	  return result.concat(left).concat(right)
	}

	function mergeSort(items) {
	  if (items.length == 1) {
	    return items
	  }
	  var middle = Math.floor(items.length / 2),
	    left = items.slice(0, middle),
	    right = items.slice(middle);
	  return merge(mergeSort(left), mergeSort(right))
	}
	/*一个长度为n的数组最终会调用mergeSort() 2*n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误*/
	```
3. 程序遇到栈溢出错误并不一定要修改整个算法，这只是表明递归并不是最好的实现方式。这个合并排序算法同样可以用迭代实现
 	```javascript
	function mergeSort(items) {
	  if (item.length == 1) {
	    return items
	  }
	  var work = []
	  for (var i = 0, len = item.length; i < len; i++) {
	    work.push([items[i]])
	  }
	  work.push([])
	  for (var lim = len; lim > 1; lim = (lim + 1) / 2) {
	    for (var j = 0, k = 0; k < lim; j++, k += 2) {
	      work[j] = merge(work[k], work[k + 1])
	    }
	    work[j]
	  }
	  return work[0]
	}
	/*
	这个版本的mergeSort()函数功能与前例相同却没有使用递归。尽管迭代版本的合并排序算法比递归实现得要慢一些，
	但它不会像递归版本那样受调用栈限制的影响。把递归算法改用迭代实现是避免栈溢出错误的方法之一
	*/
	```
### Memoization
<br>&ensp;&ensp;&ensp;&ensp;减少工作量就是最好的性能优化技术。代码要处理的事越少，它的运行速度就越快。Memoization正是一种避免重复工作的方法，它缓存前一个计算结果供后续计算使用，避免了重复工作。这使得它成为递归算法中有用的技术。
```javascript
function factorial(n){
  if(n==0){
    return 1
  }else{
    return n* factorial(n-1)
  }
}
```
________
# 字符串和正则表达式
### 字符串连接
1. 加(+)和加等(+=)操作符
	```javascript
 	str += 'one' + 'two';
	/*此代码在运行时，会经历四个步骤
	  1) 在内存中创建一个临时字符串
	  2) 连接后的字符串"onetwo"被赋值给该临时字符串
	  3) 临时字符串与str当前的值连接
	  4) 结果赋值给str
	*/
	```
	```javascript
	str +="one"
	str +="two"
	/*
	此代码用两行语句直接附加内容给str，从而避免了产生临时字符串。在大多数浏览器中会提速10%~40%
	*/
	```
	```javascript
	str = str+"one"+"two"
	/*
	赋值表达式由str开始作为基础，每次给它附加一个字符串，由左向右依次连接，因此避免了使用临时字符串。
	这与浏览器合并字符串时分配内存的方法有关。除IE外，其他浏览器会尝试为表达式左侧的字符串分配更多的内存，
	然后简单地将第二个字符串拷贝至它的末尾。如果在一个循环中，基础字符串位于最左端的位置，
	就可以避免重复拷贝一个逐渐变大的基础字符串
	*/
	```
2. 数组项合并
	+ Array.prototype.join 方法将数组的所有元素合并成一个字符串，它接收一个字符串参数作为分隔符插入每个元素的中间。
	+ 在大多数浏览器中，数组项合并比其他字符串连接方法更慢。但事实上，它却是IE7及更早版本浏览器中合并大量字符串唯一高效的途径。
3. String.prototype.concat
	+ 字符串的原生方法concat能接收任意数量的参数，并将每一个参数附加到所调用的字符串上。这是最灵活的字符串合并方法，因为你可以用它只附加一个字符串，或者同时附加多个字符串，以到整个字符串数组。
	+ 遗憾的是，在多数情况下，使用concat比使用简单的+ 和 +=稍慢，尤其是在IE、Opera和Chrome中慢得更明显。
### 正则表达式优化
1. 正则表达式工作原理
<br>正则表达式处理的基本步骤
	1) 编译
		<br>当你创建了一个正则表达式对象(使用正则直接量或RegExp构造函数)，浏览器会验证你的表达式，然后把它转化为一个原生代码程序，用于执行匹配工作。如果你把正则对象赋值给一个变量，可以避免重复执行这一步骤
	2) 设置起始位置
		<br>当正则类进入使用状态，首先要确定目标字符串的起始搜索位置。它是字符串的起始字符，或者由正则表达式的lastIndex属性指定，但是当它从第四步返回到这里时（由于尝试匹配失败），此位置则在最后一次匹配的起始位置的下一位字符的位置上。
	3) 匹配每个正则表达式字元
		<br>一旦正则表达式知道开始位置，它会逐个检查文本和正则表达式模式。当一个特定的字元匹配失败时，正则表达式会试着回溯到之前尝试匹配的位置上，然后尝试其他可能的路径
	4) 匹配成功或失败
		<br>如果在字符串当前的位置发现了一个完全匹配，那么正则表达式宣布匹配成功。如果正则表达式所有的可能路径都没有匹配到，正则表达式引擎会回退到第二步，然后从下一个字符重新尝试。当字符串的每个字符（以及最后一个字符串后面的位置）都经历这个过程，如果还没有成功匹配，那么正则表达式就宣布彻底匹配失败。
2. 理解回溯
	+ 分支与回溯
	+ 重复与回溯
	```javascript
	var str = "<p>Para 1.</p>" +
	  "<img src='smiley.jpg'>" +
	  "<p>Para 2.</p>" +
	  "<div>DIV.</div>"
	str.match(/<p>.*?<\/p>/i)
	```
	1) 这个正则表达式一开始就匹配了字符串的前三个字符`<p>`，然后匹配`.*`。点号(.)能匹配除换行符以外的任意字符，贪婪量词星号(*)表示重复零次或多次——尽可能匹配多次。因为目标字符串中没有换行符，那么它会吞并其他所有字符。不过这个正则表达式中仍有更多内容需要匹配，因此正则表达式尝试匹配< 。 它在字符串末尾处匹配失败，于是正则表达式每次回溯一个字符，继续尝试匹配<， 直到回溯至`</div>`标签的首字符<。接下一尝试匹配`\/`(转义反斜杠)，匹配成功，然后是p，匹配失败。正则表达式继续回溯，并重复这一过程，直到最后匹配到第二段末尾的`</p>`，匹配成功返回。扫描的范围从第一段头部开始直接到最后一段的尾部，这可能并不是你想要的结果。
	2) 你可以通过贪婪量词(`*`)替换成惰性(非贪婪)量词`*?`, 以匹配单个段落。惰性量词的回溯工作以相反的方式进行。当正则表达式`/<p>.*?<\/p>/`匹配到`.*?`时，它先尝试全部跳过并匹配接下来的`<\/p>`。这样做是因为*? 会重复匹配前一个字符零次和多次，次数尽可能地少，而最小的重复次数就是零次。但是，当紧接着的<无法匹配当前字符，正则表达式会回溯并尝试匹配下一个最小值：1.它像这个继续向前回溯，直到第一段末尾，在那里量词后面的`<\/p>`能够完全匹配
3. 回溯失控
	+ 当正则表达式导致你的浏览器假死数秒、数分钟、甚至更长时间，问题很可能是因为回溯失控。
	+ 解决方案: 具体化
	+ 使用预查和反向引用的模拟原子组
4. 基准测试的说明
	+ 由于正则表达式的性能受所应用的文本影响而产生很大差异，因此没有简单的方法可以测试正则表达式之间的性能差别。为了得到最好的结果，你需要用各种字符串来测试你的正则表达式，包括不同长度的、不匹配的和近似匹配的。
5. 更多提高正则表达式效率的方法
	1) 关注如何让匹配更快失败
		<br>正则表达式慢的原因通常是匹配失败的过程慢，而不是匹配成功的过程慢。这是因为，如果你使用正则表达式来匹配一个大字符串的一小部分，该正则表达式匹配失败的位置比匹配成功的位置要多得多。
	2) 正则表达式以简单、必需的字元开始
		<br>最理想的情况是，一个正则表达式的起始标记应当尽可能快速地测试并排除明显不匹配的位置。这样说来好的起始标记通常是一个锚(^或$)、特定字符串(比如：x或\u263A)、字符类(比如：[a-z]或类似\d的速记词)和单词边界(\b)。如果可能的话，避免以分组或选择字元开头，避免类似/one|two/的顶层分支。
	3) 使用量词模式，使它们后面的字元互斥
		<br>当字符与字元相邻或子表达式能够重叠匹配时，正则表达式尝试拆解文本的路径数量将增加。为避免这种情况，尽量具体化你的匹配模式。当你想表达“[^”\s\n]”时不要使用“.*?”(它依赖回溯)
	4) 减少分支数量，缩小分支范围
		+ 分支使用竖线 | 可能要求在字符串的每一个位置上测试所有分支选项。你通常可以通过使用字符集和选项组件来减少对分支的需求，或将分支在正则表达式上的位置推后
		+ 字符集比分支更快，因为它使用位向量(或其他快速实现方式)而不是回溯。当分支必不可少时，将常用分支放在最前面，如果这样做不影响正则表达式匹配的话。
	5) 使用非捕获组
		<br>捕获组消耗时间和内存来记录反向引用，并使它保持最新。如果你不需要一个反向引用，可使用非捕获组来避免这些开销，比如用(?:...)来替代(...)。当需要全文匹配的反向引用时，人们喜欢把正则表达式包装在一个捕获组中。这是不必要的，因为你可以使用其他方法引用全文匹配，比如，使用regexp.exec()返回数组的第一项，或在替换字符串中使用$&
	6) 只捕获感兴趣的文本以减少后处理
		<br>作为上一条的补充说明，如果你需要引用匹配的一部分，应该采取一切手段捕获那些片段，再使用反向引用来处理。
	7) 暴露必需的字元
	8) 使用合适的量词
		<br>正如“重复和回溯”中所讨论到的那样，贪婪和惰性量词的匹配过程有较大区别，即便处理相同的字符串。
	9) 把正则表达式赋值给变量并重用它们
	10) 将复杂的正则表达式拆分为简单的片段
6. 何时不使用正则表达式
	<br>所有的字符串方法速度都很快，当你搜索那些并不依赖正则表达式复杂特性的字面字符串时，它们有助于避免正则表达式带来的性能开销
________
# 快速响应的用户界面
### 浏览器UI线程
<br> 用于执行JavaScript和更新用户界面的进程通常被称为"浏览器UI线程"(尽管对所有浏览器来说，称为“线程”不一定准确)。UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是运行JavaScript代码，要么是执行UI更新，包括重绘和重排。
1. 浏览器限制
	+ 浏览器限制了JavaScript任务的运行时间。这种限制是有必要的，它确保某些恶意代码不能通过永不停止的密集操作锁住用户的浏览器或计算机。
	+ 此类限制分两种：调用栈大小限制和长时间运行脚本限制。长时间运行脚本限制有时被称为长时间运行脚本定时器或失控脚本定时器，但其基本原理是浏览器会记录一个脚本的运行时间，并在达到一定限度时终止它。
	+ 有两种方法可以度量脚本运行了多“长”。第一种是记录自脚本开始以来执行的语句数量。第二种是记录脚本执行的总时长。都会因用户机器性能而有所差异。最根本的是方法是从一开始就避免它们。
2. 多久才算“太久”
	+ 如果界面在100毫秒内响应用户输入，用户会认为自己在“直接操纵界面中的对象”。超过100毫秒意味着用户会感到自己与界面失去联系。由于JavaScript运行时无法更新UI，所以如果JavaScript运行时间超过100毫秒，用户就会感觉失去了对界面的控制。
	+ 因此最好的方法是，限制所有JavaScript任务在100毫秒或更短的时间内完成，以避免类似情况出现。这种测量应该以你必须支持的最慢的浏览器为基准
### 使用定时器让出时间片段
<br>尽管你尽了最大努力，但难免会有一些复杂的JavaScript任务不能在100毫秒或更短时间内完成。这个时候，最理想的方法是让出UI线程的控制权，使得UI可以更新。让出控制权意味着停止执行JavaScript，使UI线程有机会更新，然后再继续执行JavaScript。于是JavaScript定时器走进了我们的视野。
1. 定时器基础
	+ 定时器与UI线程的交互方式有助于把运行耗时较长的脚本拆分为较短的片段。调用setTimeout()或setInterval()会告诉JavaScript引擎先等待一定时间，然后添加一个JavaScript任务到UI队列。
	+ 请记住，第二个参数表示任务何时被添加到UI队列，而不是一定会在这段时间后执行；这个任务会等待队列中其他所有任务执行完毕才会执行
	+ 无论发生何种情况，创建一个定时器会造成UI线程暂停，如同它从一个任务切换到下一个任务。因此，定时器代码会重置所有相关的浏览器限制，包括长时间运行脚本定时器。此外，调用栈也在定时器的代码中重置为0。这一特性使得定时器成为长时间运行JavaScript代码理想的跨浏览器解决方案。
2. 使用定时器处理数组
	<br>它的基本方法是把循环的工作分解到一系列定时器中
	```javascript
	function processArray(items, process, callback) {
	  var todo = items.concat() // 克隆原数组
	  setTimeout(function() {
	    process(todo.shift())
	    if (todo.length > 0) {
	      setTimeout(arguments.callee, 25)
	    } else {
	      callback(items)
	    }
	  }, 25)
	}
	```
	<br>使用定时器处理数组的副作用是处理数组的总时长增加了。这是因为在每一个条目处理完成后UI线程会空闲出来，并且在下一条目开始处理之前会有一段延时。尽管如此，为避免锁定浏览器给用户带来的糟糕体验，这种取舍是必要的。
3. 记录代码运行时间
	<br>可以通过原生的Date对象来跟踪代码的运行时间，这是大多数JavaScript分析工具的工作原理
	```javascript
	function timeProcessArray(items, process, callback) {
	  var todo = items.concat()
	  setTimeout(function() {
	    var start = +new Date() // +把Date对象转化成数字
	    do {
	      process(todo.shift())
	    } while (todo.length > 0 && (+new Date() - start < 50))
	    if (todo.length > 0) {
	      setTimeout(arguments.callee, 25)
	    } else {
	      callback(items)
	    }
	  })
	}
	```
4. 定时器与性能
	<br>当多个重复的定时器同时创建往往会出现性能问题。因为只有一个UI线程，而所有的定时器都在争夺运行时间。
### Web Workers
+ 自JavaScript诞生以来，还没有办法在浏览器UI线程之外运行代码。Web Workers API改变了这种状况，它引入了一个接口，能使代码运行且不占用浏览器UI线程的时间
+ Web Workers给Web应用带来潜在的巨大性能提升，因为每个新的Worker都在自己的线程中运行代码。这意味着Worker运行代码不仅不会影响浏览器UI，也不会影响其他Worker运行的代码。
1. Worker运行环境
	+ 由于Web Worker没有绑定UI线程，这也意味着它们不能访问浏览器的许多资源。JavaScript和UI共享同一进程的部分原因是它们之间互相访问频繁，因此这些任务失控会导致糟糕的用户体验。
	+ 每个Web Worker都有自己的全局运行环境，其功能只是JavaScript特性的一个子集。由如下部分组成
		1) 一个navigator对象，只包括四个属性：appName、appVersion、userAgent和platform
		2) 一个location对象(与window.location相同，不过所有属性都是只读的)
		3) 一个self对象，指向全局worker对象
		4) 一个importScripts()方法，用来加载Worker所用到的外部JavaScript文件
		5) 所有的ECMAScript对象
		6) XMLHttpRequest构造器
		7) setTimeout()、setInterval()
		8) close()方法，它能立即停止Worker运行
2. 与Worker通信
	<br>Worker与网页代码通过事件接口进行通信。网页代码可以通过postMessage()方法给Worker传递数据，它接收一个参数，即需要传递给Worker的数据。此外，Worker还有一个用来接收信息的onmessage事件处理器
3. 加载外部文件
	<br>Worker通过importScripts()方法加载外部JavaScript文件，该方法接收一个或多个JavaScript文件URL作为参数。importScripts()的调用过程是阻塞式的，直到所有文件加载并执行完成之后，脚本才会继续运行。由于Worker在UI线程之外运行，所以这种阻塞并不会影响UI反应。
4. 实际应用
	+ Web Workers 适用于那些处理纯数据，或者与浏览器UI无关的长时间运行脚本。
	+ 可能受益的任务如下：
		1) 编码/解码大字符串
		2) 复杂数学运算(包括图像或视频处理)
		3) 大数组排序
	+ 任何超过100毫秒的处理过程，都应当考虑Worker方案是不是比基于定时器的方案更为合适，当前，前提是浏览器支持Web Workers.
_________
# Ajax
### 数据传输
1. XMLHttpRequest
	<br>使用XHR时，POST和GET的对比
	1) 对于那些不会改变服务器状态，只会获取数据(这被称为“幂等行为”)的请求，应该使用GET。经GET请求的数据会被缓存起来，如果需要多次请求同一数据的话，它会有助于提升。
	2) 只有当请求的URL加上参数的长度超过2048个字符时，才应该用POST获取数据。这是因为IE限制URL长度，过长时将会导致请求的URL被截断
2. 动态脚本注入
	+ 这种技术克服了XHR的最大限制：它能跨域请求数据。这是一个Hack，你不需要实例化一个专用对象，而可使用JavaScript创建一个新脚本标签，并设置它的src属性为不同域的URL
	+ 但是与XHR相比，动态脚本注入提供的控制是有限的。
		1) 不能设置请求的头信息。参数传递也只能使用GET方式，而不是POST方式。
		2) 不能设置请求的超时处理或重试；事实上，就算失败了也不一定知道
		3) 必须等待所有数据都已返回，才可以访问它们
		4) 不能访问请求的头信息，也不能把整个响应消息作为字符串来处理
		5) 因为响应消息作为脚本标签的源码，它必须是可执行的JavaScript代码。不能使用纯XML、纯JSON或其他任何格式的数据，无论哪种格式，都必须封装在一个回调函数中
	+ 尽管有这些限制，这项技术的速度却非常快。响应消息是作为JavaScript执行，而不是作为字符串需要进一步处理。正因为如此，它有潜力成为客户端获取并解析数据最快的方法。
	+ 使用这种技术从那些你无法直接控制的服务器上请求数据时需要小心。JavaScript没有任何权限和访问控制的概念，因此你使用动态脚本注入添加到页面中的任何代码都可以完全控制整个页面。包括修改任何内容，把用户重定向到其他网站，甚至跟踪用户在页面上的操作并发送数据到第三方服务器。
3. Multipart XHR
	+ Multipart XHR(MXHR)允许客户端只用一个HTTP请求就可以从服务器向客户端传递多个资源。它通过在服务器端将资源(CSS文件、HTML片段、JavaScript代码或base64编码的图片)打包成一个由双方约定的字符串分割的长字符串并发送到客户端。然后用JavaScript代码处理这个长字符串，并根据它的mime-type类和传入的其他“头信息”解析出每个资源
	+ 使用这个技术有一些缺点，其中最大的缺点是以这种方式获得的资源不能被浏览器缓存。如果你用MXHR获取一个特定的CSS文件，然后在下一个页面中正常加载它，它将不会存在于缓存里。这是因为合并后的资源是作为字符串传递的，然后被JavaScript代码分解成片段。由于无法用编程的方式向浏览器缓存里注入文件，因此用这种方获取的资源无法被缓存。
	+ 另一个缺点是，老版本的IE不支持readyState为3的状态和data:URL。IE8倒是两个都支持，但在IE6和IE7中必须设法变通
	+ 尽管有这些缺点，但某些情况下MXHR依然能显著提升页面的整体性能：
		a) 页面包含了大量其他地方用不到的资源(因此也无须缓存)，尤其是图片
		b) 网站已经在每个页面中使用一个独立打包的JavaScript或CSS文件以减少HTTP请求：因为对每个页面来说这些文件都唯一的，所以并不需要从缓存中读取数据，除非重载页面。
	+ 由于HTTP请求是Ajax中最大的瓶颈之一，因此减少其需要的数量会对整个页面的性能有很大的影响。
4. 发送数据
	1) XHR
	2) Beacon(信标)
 		<br>这项技术非常类似动态脚本注入。使用JavaScript创建一个新Image对象，并把src属性设置为服务器上脚本的URL。该URL包含了我们要通过GET传回的键值对数据
		```javascript
	 	var url = '/status_tracker.php'
	 	var params = [
	 	  'step=2',
	 	  'time=1248027314'
	 	]
	 	(new Image()).src = url + '?' + params.join('&')
		```
		+ 服务器会接收到数据并保存下来，它无须向客户端发送任何回馈信息，因此没有图片会实际显示出来。这是给服务器回传信息最有效的方式。它的性能消耗很小，而且服务器的错误完全不会影响到客户端。
		+ 信标是向服务器回传数据最快且最有效的方式。服务器根本不需要发送任何响应正文，因此你也无须担心客户端下载数据。唯一的缺点是能接收的响应类型是有限的。如果需要返回大量数据给客户端，那么请使用XHR。如果只关心发送数据到服务器，那么请使用图片信标
### 数据格式
<br>通常来说数据格式越轻量级越好，JSON和字符分隔的自定义格式是最好的。如果数据集很大并且对解析时间有要求，那么就从如下两种格式中做出选择：
1) JSON-P数据，使用动态脚本注入获取。它把数据当作可执行的JavaScript而不是字符串，解析速度极快。它能跨域使用，但涉及敏感数据时不应该使用它。
2) 字符分隔的自定义格式，使用XHR或动态脚本注入获取，用split()解析。这项技术解析大数据集比JSON-P略快，而且通常文件尺寸更小
### Ajax性能指南
1. 缓存数据
	1) 在服务器端，设置HTTP头信息以确保响应会被浏览器缓存
	2) 在客户端，把获取至信息存储到本地，从而避免再次请求
_________
# 编程实践
### 避免双重求值
+ 当在JavaScript代码中执行另一段代码时，都会导致双重求值的性能消耗。此代码首先会以正常的方式求值，然后在执行过程中对包含于字符串中的代码发起另一个求值运算。双重求值是一项代价昂贵的操作，它比直接包含的代码执行速度慢许多
	```javascript
	var item = eval("array[0]")
	/*
	第次调用eval()时都要创建一个新的解释器/编译器实例。同样的过程也会发生在使用Function()、
	setTimeout()和setInterval()时，这必然使得代码执行的速度变慢。
	*/
	```
+ 大多数时候，没必要使用eval()和Function()，因此最好避免使用它们。至于另外两个函数，setTimeout()和setInterval()，建议传入函数而不是字符串来作为第一个参数
+ 避免双重求值是实现JavaScript运行期性能最优化的关键所在。
### 使用Object/Array直接量
<br>在JavaScript中创建对象和数组的方法有很多种，但使用对象和数组直接量是最快的方式。同时，直接量还有助于节省代码量，以减小整个文件的尺寸。
### 避免重复工作
1. 避免无谓的工作的概念有两重意思：别做无关紧要的工作，别重复做已经完成的工作。第一部分通常很容易在代码重构时发现。而第二部分往往难以界定，因为工作可能会在各种场景下加为各种理由而被重复
	<br>也许最常见的重复工作就是浏览器探测。基于浏览器的功能作为判断导致产生大量的代码。
	```javascript
	function addHandler(target, eventType, handler) {
	  if (target.addEventListener) {
	    target.addEventListener(eventType, handler, false)
	  } else {
	    target.attachEvent("on" + eventType, handler)
	  }
	}
	/*
	隐藏的性能问题在于每次函数调用时都做了重复工作。因为每次的检查过程都相同
	*/
	```
2. 延迟加载
 	<br>第一种消除函数中的重复工作的方法是延迟加载(lazy loading)。延迟加载意味着在信息被使用前不会做任何操作。
	```javascript
	function addHandler(target, eventType, handler) {
	  if (target.addEventListener) {
	    addHandler = function(target, eventType, handler) {
	      target.addEventListener(eventType, handler, false)
	    }
	  } else {
	    addHandler = function(target, eventType, handler) {
	      target.attachEvent("on" + eventType, handler)
	    }
	  }
	  addHandler(target, eventType, handler)
	}
	/*
	1）这个方法实现了延迟加载模式。
	2）调用延迟加载函数时，第一次总会消耗较长的时间，因为它必须运行检测接着再调用另一个函数并完成任务。
	但随后调用相同的函数会更快，因为不需要再执行检测逻辑。
	3）当一个函数在页面中不会立刻调用时，延迟加载是最好的选择
	*/
	```
3. 条件预加载
	<br>条件预加载(conditional advanceloading)，它会在脚本卡加载期间提前检测，而不会等到函数被调用。检测的操作依然只有一次，只是它在过程中来得更早
	```javascript
	var addHandler = document.body.addEventListener ?
	  function(target, eventType, handler) {
	    target.addEventListener(eventType, handler, false)
	  } :
	  function(target, eventType, handler) {
	    target.attachEvent("on" + eventType, handler)
	  }
	/*
	条件预加载确保所有函数调用消耗的时间相同。其代码是需要在脚本加载时就检测，而不是加载后。
	预加载适用于一个函数马上就要被用到，并且在整个页面的生命周期中出现的场合。
	*/
	```
### 使用速度快的部分
1. 位操作
	+ 有好几种方法来利用位操作符提升JavaScript的速度。
	+ 首先是使用位运算代替纯数学操作，如对2的取模运算
	```javascript
	if(i%/2){}else{}
	if(i&1){}else{} // 位运算
	/*
	32位的数字的二进制底层表示，偶数的最低位是0，奇数的是1。与1的按位与运算可得相同的效果
	*/
	```
2. 原生方法
	+ 无论你的JavaScript代码如何优化，都永远不会比JavaScript引擎提供的原生方法更快。道理很简单：JavaScript的原生部分在你写代码前就已经存在浏览器中了，并且都是用低级语言写的，诸如C++。这意味着这些方法会被编译成机器码，成为浏览器的一部分。
	+ 当原生方法可用时，尽量使用它们，特别是数学运算和DOM操作。如Math对象方法， css的 querySelector()/querySelectorAll()
